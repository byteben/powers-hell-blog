<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://powers-hell.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://powers-hell.com/" rel="alternate" type="text/html" /><updated>2021-06-14T04:36:52+00:00</updated><id>https://powers-hell.com/feed.xml</id><title type="html">Powers Hell</title><subtitle>great/power/is/great/fun &gt;</subtitle><entry><title type="html">Working with Intune Settings Catalog using PowerShell and Graph</title><link href="https://powers-hell.com/2021/03/08/working-with-intune-settings-catalog-using-powershell-and-graph/" rel="alternate" type="text/html" title="Working with Intune Settings Catalog using PowerShell and Graph" /><published>2021-03-08T12:46:00+00:00</published><updated>2021-03-08T12:46:00+00:00</updated><id>https://powers-hell.com/2021/03/08/working-with-intune-settings-catalog-using-powershell-and-graph</id><content type="html" xml:base="https://powers-hell.com/2021/03/08/working-with-intune-settings-catalog-using-powershell-and-graph/">&lt;p&gt;Microsoft has recently introduced even more ways to create device configuration profiles..&lt;/p&gt;

&lt;p&gt;The new profile type, named &lt;strong&gt;Settings Catalog&lt;/strong&gt;, allows us to explicitly define and configure a policy that has &lt;strong&gt;only&lt;/strong&gt; the settings that they want for that profile, nothing more. Additionally, the existing configuration profiles and ADMX templates have been migrated to the &lt;strong&gt;templates&lt;/strong&gt; profile type.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/33951277/119915226-66caae00-bfa5-11eb-8cc5-4eccfce7787e.png&quot; title=&quot;Create a setting profile&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/33951277/119915226-66caae00-bfa5-11eb-8cc5-4eccfce7787e.png&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I sat down with &lt;a href=&quot;https://twitter.com/MikeDanoski&quot;&gt;Mike Danoski&lt;/a&gt; for an in-depth chat about this on the &lt;a href=&quot;https://intune.training&quot; data-type=&quot;URL&quot; data-id=&quot;https://intune.training&quot;&gt;Intune.Training&lt;/a&gt; Channel (video below).&lt;/p&gt;

&lt;div class=&quot;video-container&quot;&gt;
    &lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/sqIKcWXPvyI&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;After spending time with Mike and seeing how settings catalog profiles work from the endpoint portal user interface, I immediately wanted to see what I could do with this new device management framework via graph.&lt;/p&gt;

&lt;p&gt;So let’s dive in and play!&lt;/p&gt;

&lt;h2 id=&quot;pulling-settings-catalog-policies-from-graph&quot;&gt;&lt;strong&gt;Pulling settings catalog policies from Graph&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;First, let’s create a policy from the endpoint portal and see what is required to retrieve the policy data.&lt;/p&gt;

&lt;p&gt;For this demo, I’ve created a simple settings catalog with a few settings around bitlocker as shown below.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/33951277/119915357-ad200d00-bfa5-11eb-97fc-2cef877def1a.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/33951277/119915357-ad200d00-bfa5-11eb-97fc-2cef877def1a.png&quot; alt=&quot;image-1&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The first thing we need to do, as always, is authenticate to graph - At this point I shouldn’t need to explain what is happening here. We will use the msal.ps module to make things easier.&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot; title=&quot;Configure Authentication for Graph.&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell&quot;&gt;$params = @{
    ClientId = 'd1ddf0e4-d672-4dae-b554-9d5bdfd93547'
    TenantId = 'powers-hell.com'
    DeviceCode = $true
}
$AuthHeader = @{Authorization = (Get-MsalToken @params).CreateAuthorizationHeader()}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we’ve authenticated to graph, let’s use the new graph endpoint &lt;strong&gt;configurationPolicies&lt;/strong&gt; to have a look at how this new feature looks in the backend.&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot; title=&quot;Get configurationPolicies&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell&quot;&gt;$baseUri = &quot;https://graph.microsoft.com/beta/deviceManagement&quot;
$restParam = @{
    Method = 'Get'
    Uri = &quot;$baseUri/configurationPolicies&quot;
    Headers = $authHeaders
    ContentType = 'Application/json'
}

$configPolicies = Invoke-RestMethod @restParam
$configPolicies.value&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, the code above is quite simple, and looking at the resultant data shows we get some basic data back showing all available &lt;strong&gt;settings catalog&lt;/strong&gt; policies that are in our tenant (in our case just the one).&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/33951277/119915408-ca54db80-bfa5-11eb-9be7-d9d02f8cd82c.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/33951277/119915408-ca54db80-bfa5-11eb-9be7-d9d02f8cd82c.png&quot; alt=&quot;image-2&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Ok, so we’ve got the basic metadata of our policy - so let’s grab the id from the previous call and dive in further..&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;$policyId = $configPolicies.value[0].id #grabbing the id from the previous code block
$restParam = @{
    Method = 'Get'
    Uri = &quot;$baseUri/configurationPolicies('$policyId')/settings&quot;
    Headers = $authHeaders
    ContentType = 'Application/json'
}

$configPolicySettings = Invoke-RestMethod @restParam
$configPolicySettings.value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code above returns data on all available settings that we configured in our policy..&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/33951277/119915446-e5bfe680-bfa5-11eb-95ee-c997cae4af14.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/33951277/119915446-e5bfe680-bfa5-11eb-95ee-c997cae4af14.png&quot; alt=&quot;image-3&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;if we drill in to one of the &lt;strong&gt;settingInstance&lt;/strong&gt; objects, we should see more info..&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/33951277/119915455-ea849a80-bfa5-11eb-8e0a-e3b960be372e.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/33951277/119915455-ea849a80-bfa5-11eb-8e0a-e3b960be372e.png&quot; alt=&quot;image-4&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;As we can see, this particular setting is for &lt;strong&gt;allow warning for other disk encryption&lt;/strong&gt; - as clearly defined in the &lt;strong&gt;definitionId&lt;/strong&gt; value. If we drill into the &lt;strong&gt;choiceSettingValue&lt;/strong&gt; item, we will see the applied value and any other child properties within that setting..&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/33951277/119915465-efe1e500-bfa5-11eb-868b-3201648c081f.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/33951277/119915465-efe1e500-bfa5-11eb-868b-3201648c081f.png&quot; alt=&quot;image-5&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Here we can see the value of &lt;strong&gt;allow warning for other disk encryption&lt;/strong&gt; is set to 0 - or false, which correlates to our policy set from the endpoint portal.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/33951277/119915536-1011a400-bfa6-11eb-8421-eeca2c61bcb9.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/33951277/119915536-1011a400-bfa6-11eb-8421-eeca2c61bcb9.png&quot; alt=&quot;image-6&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Here we can see the &lt;strong&gt;child&lt;/strong&gt; setting of &lt;strong&gt;allow standard user encryption&lt;/strong&gt; with the setting value of 1 - or true.&lt;/p&gt;

&lt;p&gt;This example shows how simple it is to capture the basic building blocks of a settings catalog policy. But for those interested to dig deeper, why not check out what happens when you run the same example from above while expanding the &lt;strong&gt;settingDefinitions&lt;/strong&gt; property..&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/33951277/119915557-1acc3900-bfa6-11eb-8374-b50a0a1b2d82.gif&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/33951277/119915557-1acc3900-bfa6-11eb-8374-b50a0a1b2d82.gif&quot; alt=&quot;settingsDefinition&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Cool, huh? literally everything about each and every setting is available to us if we just spend the time to dig into graph a little bit!&lt;/p&gt;

&lt;h2 id=&quot;building-a-policy-from-scratch&quot;&gt;Building a policy from scratch&lt;/h2&gt;

&lt;p&gt;Now, before we begin, I’m going to put this out there - settings catalog policies are probably not the easiest things to build from scratch..&lt;/p&gt;

&lt;p&gt;There is LOTS of metadata that you need to know for each setting before you can build out the policies. However, the concepts shown below can also be leveraged to maintain &lt;strong&gt;reference templates&lt;/strong&gt; that can be captured and redeployed to other tenants to allow seamless management of multiple tenants with minimal effort.&lt;/p&gt;

&lt;p&gt;Enough stalling, let’s see what’s required.&lt;/p&gt;

&lt;h3 id=&quot;getting-all-settings-data&quot;&gt;Getting all settings data&lt;/h3&gt;

&lt;p&gt;So the first question that you may be asking, is, “How do I get the data that I need for the settings that I want to add to my catalog policy?” Luckily, Microsoft has an endpoint in graph that will return all possible settings currently available for the settings catalog.&lt;/p&gt;

&lt;p&gt;We can capture all necessary metadata on those available settings by using the &lt;strong&gt;deviceManagement/configurationSettings&lt;/strong&gt; endpoint.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;$restParam = @{
    Method = &quot;Get&quot;
    Uri = &quot;$baseUri/configurationSettings&quot;
    Headers = $authHeaders
    ContentType = 'Application/Json'
}
$settingsData = Invoke-RestMethod @restParam
$settingsData.value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let’s run the above code and see what we get back..&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/33951277/119915626-40f1d900-bfa6-11eb-9bd0-cab0d19c0e2f.gif&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/33951277/119915626-40f1d900-bfa6-11eb-9bd0-cab0d19c0e2f.gif&quot; alt=&quot;settingsCatapalooza&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Well… that was a bit much wasn’t it! at the time of writing, there is around 2,100 settings available in the settings catalog library with more to come until it is at parity with all existing methods of device configuration (configuration items, ADMX templates, endpoint baselines etc).&lt;/p&gt;

&lt;p&gt;Let’s filter the settings by a setting &lt;strong&gt;definitionId&lt;/strong&gt; that we know (notice that the definitionId isnt a GUID? welcome to the future…)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;$settingsData.value | where {$_.id -eq 'device_vendor_msft_bitlocker_allowwarningforotherdiskencryption'}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/33951277/119915662-52d37c00-bfa6-11eb-8d82-623eafe6e2b1.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/33951277/119915662-52d37c00-bfa6-11eb-8d82-623eafe6e2b1.png&quot; alt=&quot;image-7&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Weird… doesn’t that look the same as the expanded &lt;strong&gt;settingsDefinitions&lt;/strong&gt; content from earlier? That’s because it is literally the same data! We can dig into this data to find out the available options for each setting, but let’s skip that for now and just build our example policy from scratch..&lt;/p&gt;

&lt;h3 id=&quot;posting-a-settings-catalog-policy-to-intune-from-graph&quot;&gt;Posting a settings catalog policy to Intune from Graph&lt;/h3&gt;

&lt;p&gt;Conceptually we now should understand what’s required here. We have some metadata around what the policy is called to which we attach whichever settings we want attributed to our new policy profile. So let’s rebuild the original policy in PowerShell!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;$baseUri = 'https://graph.microsoft.com/beta/deviceManagement/configurationPolicies'

#region build the policy
$newPolicy = [pscustomobject]@{
    name         = &quot;Bitlocker Policy from PowerShell&quot;
    description  = &quot;we built this from PowerShell!&quot;
    platforms    = &quot;windows10&quot;
    technologies = &quot;mdm&quot;
    settings     = @(
        @{
            '@odata.type'   = &quot;#microsoft.graph.deviceManagementConfigurationSetting&quot;
            settingInstance = @{
                '@odata.type'       = &quot;#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance&quot;
                settingDefinitionId = &quot;device_vendor_msft_bitlocker_allowwarningforotherdiskencryption&quot;
                choiceSettingValue  = @{
                    '@odata.type' = &quot;#microsoft.graph.deviceManagementConfigurationChoiceSettingValue&quot;
                    value         = &quot;device_vendor_msft_bitlocker_allowwarningforotherdiskencryption_0&quot;
                    children      = @(
                        @{
                            '@odata.type'       = &quot;#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance&quot;
                            settingDefinitionId = &quot;device_vendor_msft_bitlocker_allowstandarduserencryption&quot;
                            choiceSettingValue  = @{
                                '@odata.type' = &quot;#microsoft.graph.deviceManagementConfigurationChoiceSettingValue&quot;
                                value         = &quot;device_vendor_msft_bitlocker_allowstandarduserencryption_0&quot;
                            }
                        }
                    )
                }
            }
        }
        @{
            '@odata.type'   = &quot;#microsoft.graph.deviceManagementConfigurationSetting&quot;
            settingInstance = @{
                '@odata.type'       = &quot;#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance&quot;
                settingDefinitionId = &quot;device_vendor_msft_bitlocker_requiredeviceencryption&quot;
                choiceSettingValue  = @{
                    '@odata.type' = &quot;#microsoft.graph.deviceManagementConfigurationChoiceSettingValue&quot;
                    value         = &quot;device_vendor_msft_bitlocker_requiredeviceencryption_1&quot;
                }
            }
        }
    )
}
#endregion
#region post the request
$restParams = @{
    Method      = 'Post'
    Uri         = $baseUri
    body        = ($newPolicy | ConvertTo-Json -Depth 20)
    Headers     = $authHeaders
    ContentType = 'Application/Json'
}
Invoke-RestMethod @restParams
#endregion
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once we run this - within seconds we should have a replicated policy in our tenant!&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/33951277/119915697-65e64c00-bfa6-11eb-8cab-06a15f01b7e8.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/33951277/119915697-65e64c00-bfa6-11eb-8cab-06a15f01b7e8.png&quot; alt=&quot;image-8&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;As mentioned earlier, building these from scratch is tricky - but if you read between the lines, knowing how to capture pre-built policies via graph and using the captured JSON payload to post the same policy to a new tenant (or a few hundred tenants) should make multi-tenant device management less painful.&lt;/p&gt;

&lt;p&gt;— Ben&lt;/p&gt;</content><author><name>Ben</name></author><category term="Azure" /><category term="Graph" /><category term="Intune" /><category term="PowerShell" /><category term="Azure" /><category term="Intune" /><category term="PowerShell" /><summary type="html">Microsoft has recently introduced even more ways to create device configuration profiles.. The new profile type, named Settings Catalog, allows us to explicitly define and configure a policy that has only the settings that they want for that profile, nothing more. Additionally, the existing configuration profiles and ADMX templates have been migrated to the templates profile type.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://powers-hell.com/assets/images/2021/03/settingsCatapalooza.gif" /><media:content medium="image" url="https://powers-hell.com/assets/images/2021/03/settingsCatapalooza.gif" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Publishing PowerShell scripts to Intune with Graph</title><link href="https://powers-hell.com/2021/01/19/publishing-powershell-scripts-to-intune-with-graph/" rel="alternate" type="text/html" title="Publishing PowerShell scripts to Intune with Graph" /><published>2021-01-19T03:22:12+00:00</published><updated>2021-01-19T03:22:12+00:00</updated><id>https://powers-hell.com/2021/01/19/publishing-powershell-scripts-to-intune-with-graph</id><content type="html" xml:base="https://powers-hell.com/2021/01/19/publishing-powershell-scripts-to-intune-with-graph/">&lt;p&gt;I’ve recently been asked the question - “How can I make sure that the scripts that I publish to Intune are always set to run as 64bit instead of the default 32bit?”&lt;/p&gt;

&lt;p&gt;I thought was a great question with a few simple solutions - so let’s look at the two methods I’ve used in the past to make sure you don’t “fat finger” your way into frustration!&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;enforce-architecture-from-the-script&quot;&gt;Enforce architecture from the script&lt;/h2&gt;

&lt;p&gt;When PowerShell script deployment was initially released within Intune there was no native way to define what architecture the script would run in. This means that the script would always run in the 32bit / x86 environment as the Intune Management Extension agent was launching the scripts and the agent itself was a 32bit agent - it had no way to bootstrap out of the 32bit environment!&lt;/p&gt;

&lt;p&gt;The only solution during this period was to make your scripts bootstrap themselves into 64bit with a little bit of PowerShell magic.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;#region 64-bit elevation
if ($env:PROCESSOR_ARCHITEW6432 -eq &quot;AMD64&quot;) {
    write-Host &quot;pull on those bootstraps...&quot;
    if ($myInvocation.Line) {
        &amp;amp;&quot;$env:WINDIR\sysnative\windowspowershell\v1.0\powershell.exe&quot; -NonInteractive -executionPolicy Bypass -NoProfile $myInvocation.Line
    }
    else {
        &amp;amp;&quot;$env:WINDIR\sysnative\windowspowershell\v1.0\powershell.exe&quot; -NonInteractive -executionPolicy Bypass -NoProfile -file &quot;$($myInvocation.InvocationName)&quot; $args
    }
    exit $lastexitcode
}
#endregion
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Place that code at the top of any script you publish to Intune and you can rest easy knowing that your code will always run in the environment it should be in, regardless if you set it correctly from within Intune or not.&lt;/p&gt;

&lt;h2 id=&quot;avoid-the-endpoint-ui-and-use-graph&quot;&gt;Avoid the Endpoint UI and use Graph&lt;/h2&gt;

&lt;p&gt;Now that the option to set the architecture from within the script deployment, the above solution is conceivably “redundant” - we can set everything when we publish the script in the portal now!&lt;/p&gt;

&lt;p&gt;The problem arises however, because the default architecture setting is set to 32bit instead of the generally expected 64bit, that you can sometimes forget to set the configuration correctly from the portal.&lt;/p&gt;

&lt;p&gt;Luckily, we can move away from the Endpoint portal and use PowerShell and Graph to change the default settings to values and standardize our script publishing to avoid any of those absent-minded “user errors” that are so frustratingly common.&lt;/p&gt;

&lt;p&gt;Like all other configuration settings / device management endpoints that are exposed via Graph, all that is required is to:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Understand how the JSON payload data is formed&lt;/li&gt;
  &lt;li&gt;Authenticate to Graph&lt;/li&gt;
  &lt;li&gt;Build and publish the JSON payload to Graph&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The one extra step for script deployment is that we need to encode the script content into a base64 encoded string so that we can post the file within the JSON payload.&lt;/p&gt;

&lt;p&gt;Let’s dive into the solution together.&lt;/p&gt;

&lt;h3 id=&quot;authentication&quot;&gt;Authentication&lt;/h3&gt;

&lt;p&gt;I’ve covered this ad-nauseum, so I won’t spend time explaining it - but here’s the code snippet we will use for this example. What’s cool about this is we can handle whether or not the end user uses PowerShell 5.1 or 7.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;#region authenticate to Graph
if ($PSVersionTable.PSEdition -ne &quot;Core&quot;) {
    $auth = Get-MsalToken -ClientId &quot;d1ddf0e4-d672-4dae-b554-9d5bdfd93547&quot; -RedirectUri &quot;urn:ietf:wg:oauth:2.0:oob&quot; -Interactive
}
else {
    $auth = Get-MsalToken -ClientId &quot;d1ddf0e4-d672-4dae-b554-9d5bdfd93547&quot; -DeviceCode
}
$script:authToken = @{
    Authorization = $auth.CreateAuthorizationHeader()
}
#endregion
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;encode-the-script-to-a-base64-string&quot;&gt;Encode the script to a base64 string&lt;/h3&gt;

&lt;p&gt;Very simple - but super important. We just need to get the raw content of the script and throw it into the .Net “System.Convert” type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;#region encode the script content to base64
$scriptContent = Get-Content &quot;C:\Path\To\Script.ps1&quot; -Raw
$encodedScriptContent = [System.Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes(&quot;$scriptContent&quot;))
#endregion
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;payload-properties&quot;&gt;Payload properties&lt;/h3&gt;

&lt;p&gt;The required properties for publishing scripts to Graph are quite simple - the endpoint &lt;strong&gt;deviceManagementScripts&lt;/strong&gt; is &lt;a href=&quot;https://docs.microsoft.com/en-us/graph/api/intune-shared-devicemanagementscript-create?view=graph-rest-beta&quot; data-type=&quot;URL&quot; data-id=&quot;https://docs.microsoft.com/en-us/graph/api/intune-shared-devicemanagementscript-create?view=graph-rest-beta&quot;&gt;well documented&lt;/a&gt;, but for simplicity, the only settings we need to understand are listed below:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;Property Name&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;Data Type&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;displayName&lt;/td&gt;
      &lt;td&gt;String&lt;/td&gt;
      &lt;td&gt;Name of the device management script.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;description&lt;/td&gt;
      &lt;td&gt;String&lt;/td&gt;
      &lt;td&gt;Description of the script&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;enforceSignatureCheck&lt;/td&gt;
      &lt;td&gt;Boolean&lt;/td&gt;
      &lt;td&gt;Setting this to False disables signature check.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;fileName&lt;/td&gt;
      &lt;td&gt;String&lt;/td&gt;
      &lt;td&gt;Name of the file being uploaded.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;runas32Bit&lt;/td&gt;
      &lt;td&gt;Boolean&lt;/td&gt;
      &lt;td&gt;Setting this to False sets to 64bit&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;runAsAccount&lt;/td&gt;
      &lt;td&gt;String&lt;/td&gt;
      &lt;td&gt;Execution context - System or User&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;scriptContent&lt;/td&gt;
      &lt;td&gt;Binary&lt;/td&gt;
      &lt;td&gt;Script content - encoded as base64&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;So, knowing what we need, let’s build out the code to build the payload.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;#region build the request body
$postBody = [PSCustomObject]@{
    displayName           = &quot;Powers-Hell Configuration Script&quot;
    description           = &quot;script that configures important things&quot;
    enforceSignatureCheck = $false
    fileName              = &quot;Script.ps1&quot;
    runAs32Bit            = $false
    runAsAccount          = &quot;System&quot;
    scriptContent         = $encodedScriptContent
} | ConvertTo-Json -Depth 10
#endregion
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Quite simple - creating a PSCustomObject, filling in the property values and then immediately converting to a JSON string.&lt;/p&gt;

&lt;h3 id=&quot;post-the-request-to-graph&quot;&gt;Post the request to Graph&lt;/h3&gt;

&lt;p&gt;Once we’ve got out authentication header, we’ve encoded the script contents and built out the JSON payload, all that’s left to do is post the payload to the Graph endpoint.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;#region post the request
$postParams = @{
    Method      = &quot;Post&quot;
    Uri         = &quot;https://graph.microsoft.com/Beta/deviceManagement/deviceManagementScripts&quot;
    Headers     = $script:authToken
    Body        = $postBody
    ContentType = &quot;Application/Json&quot;
}
Invoke-RestMethod @postParams
#endregion
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we use the above basic blocks of code, we can very easily build a simple function to allow us to build out a request to publish scripts to our Intune tenant and by forcing the boolean value of &lt;strong&gt;runAs32Bit&lt;/strong&gt; to $false, we can ensure the script will always run correctly - even if we haven’t had enough coffee yet.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;#requires -module msal.ps
function Publish-ScriptToIntune {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [System.IO.FileInfo]$ScriptFilePath,

        [Parameter(Mandatory = $true)]
        [string]$DisplayName,

        [Parameter(Mandatory = $true)]
        [string]$Description,

        [Parameter(Mandatory = $false)]
        [ValidateSet(&quot;System&quot;, &quot;User&quot;)]
        [string]$RunAsAccount = &quot;System&quot;,

        [Parameter(Mandatory = $false)]
        [boolean]$EnforceSignatureCheck,

        [Parameter(Mandatory = $false)]
        [boolean]$RunAs32Bit

    )
    try {
        $script:tick = [char]0x221a
        $errorMsg = $null
        #region authenticate to Graph
        if ($PSVersionTable.PSEdition -ne &quot;Core&quot;) {
            $auth = Get-MsalToken -ClientId &quot;d1ddf0e4-d672-4dae-b554-9d5bdfd93547&quot; -RedirectUri &quot;urn:ietf:wg:oauth:2.0:oob&quot; -Interactive
        }
        else {
            $auth = Get-MsalToken -ClientId &quot;d1ddf0e4-d672-4dae-b554-9d5bdfd93547&quot; -DeviceCode
        }
        if (!($auth)) {
            throw &quot;Authentication failed.&quot;
        }
        $script:authToken = @{
            Authorization = $auth.CreateAuthorizationHeader()
        }
        #endregion
        #region encode the script content to base64
        $scriptContent = Get-Content &quot;$ScriptFilePath&quot; -Raw
        $encodedScriptContent = [System.Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes(&quot;$scriptContent&quot;))
        #endregion
        #region build the request body
        $postBody = [PSCustomObject]@{
            displayName           = $DisplayName
            description           = $Description
            enforceSignatureCheck = $EnforceSignatureCheck
            fileName              = $ScriptFilePath.Name
            runAs32Bit            = $RunAs32Bit
            runAsAccount          = $RunAsAccount
            scriptContent         = $encodedScriptContent
        } | ConvertTo-Json -Depth 10
        #endregion
        Write-Host &quot;`nPosting script content to Intune: &quot; -NoNewline -ForegroundColor Cyan
        #region post the request
        $postParams = @{
            Method      = &quot;Post&quot;
            Uri         = &quot;https://graph.microsoft.com/Beta/deviceManagement/deviceManagementScripts&quot;
            Headers     = $script:authToken
            Body        = $postBody
            ContentType = &quot;Application/Json&quot;
        }
        if ($PSCmdlet.MyInvocation.BoundParameters[&quot;Verbose&quot;].IsPresent) {
            Write-Host &quot;`n&quot;
        }
        $res = Invoke-RestMethod @postParams
        #endregion
    }
    catch {
        $errorMsg = $_.Exception.Message
    }
    finally {
        if ($auth) {
            if ($errorMsg) {
                Write-Host &quot;X`n&quot; -ForegroundColor Red
                Write-Warning $errorMsg
            }
            else {
                if ($PSCmdlet.MyInvocation.BoundParameters[&quot;Verbose&quot;].IsPresent) {
                    $res
                }
                Write-Host &quot;$script:tick Script published to Intune with ID $($res.id)&quot; -ForegroundColor Green
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As always, the code featured is available in my &lt;a href=&quot;https://github.com/tabs-not-spaces/CodeDump/tree/master/Publish-ScriptToIntune&quot;&gt;GitHub&lt;/a&gt; and I’m always up for a chat on &lt;a href=&quot;https://twitter.com/powers_hell&quot;&gt;Twitter&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;— Ben&lt;/p&gt;</content><author><name>Ben</name></author><category term="Azure" /><category term="Graph" /><category term="Intune" /><category term="PowerShell" /><category term="Graph" /><category term="Intune" /><category term="PowerShell" /><summary type="html">I've recently been asked the question - &quot;How can I make sure that the scripts that I publish to Intune are always set to run as 64bit instead of the default 32bit?&quot; I thought was a great question with a few simple solutions - so let's look at the two methods I've used in the past to make sure you don't &quot;fat finger&quot; your way into frustration!</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://powers-hell.com/assets/images/2021/01/scriptToGraph.gif" /><media:content medium="image" url="https://powers-hell.com/assets/images/2021/01/scriptToGraph.gif" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Set your Azure VPN connections to “Connect Automatically” with PowerShell</title><link href="https://powers-hell.com/2020/11/28/set-your-azure-vpn-connections-to-connect-automatically-with-powershell/" rel="alternate" type="text/html" title="Set your Azure VPN connections to “Connect Automatically” with PowerShell" /><published>2020-11-28T06:25:27+00:00</published><updated>2020-11-28T06:25:27+00:00</updated><id>https://powers-hell.com/2020/11/28/set-your-azure-vpn-connections-to-connect-automatically-with-powershell</id><content type="html" xml:base="https://powers-hell.com/2020/11/28/set-your-azure-vpn-connections-to-connect-automatically-with-powershell/">&lt;p&gt;One of my clients recently came to me asking for assistance to set up a new VPN solution. The requirements were quite simple - They were building out an Azure Point-To-Site VPN solution and needed me to come up with a way to deliver the connection to the end user devices.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;My first suggestion was to simply use the built-in VPN client that comes with Windows 10. If we use this, we can utilize the native VPN policies within Intune which let us define everything we need - including setting the connection to automatically connect. The problem, as it turned out is the native VPN client has a limit of 25 route rules per connection - something that *shouldn’t* normally be a problem, but was insurmountable in this scenario.&lt;/p&gt;

&lt;p&gt;The next suggestion was to leverage the &lt;a href=&quot;https://www.microsoft.com/en-us/p/azure-vpn-client/9np355qt2sqb&quot; data-type=&quot;URL&quot; data-id=&quot;https://www.microsoft.com/en-us/p/azure-vpn-client/9np355qt2sqb&quot;&gt;Azure VPN Client&lt;/a&gt; from the Microsoft store. This VPN client is designed to compliment the native VPN client and adds support for MFA as well as allowing connections from the native VPN interface.&lt;/p&gt;

&lt;p&gt;The only problem? There is no way to force the “connect automatically” setting in the native VPN client, thus the client’s major requirement was not met.&lt;/p&gt;

&lt;p&gt;Now, the end user can technically go in once the connection is deployed and set it themselves, but there has to be a more reliable way of doing this on behalf of the user - if it can be done via Intune for the native client, surely there has to be a way to enforce the setting? The answer, as always, is a resounding “of course!”.&lt;/p&gt;

&lt;p&gt;Before we begin, the first thing we need to do is convert the config files I was given by my network team into a format that we can silently push out.&lt;/p&gt;

&lt;p&gt;Once you’ve downloaded the Azure P2S config files, the next step is to manually import the config into the Azure VPN client (technically there is a way to do this using CLI parameters, however it’s frustratingly broken at the moment - I’ll talk about that another time!).&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/11/VPNConnectionImport-1.gif&quot; title=&quot;VPN Connection Import&quot;&gt;&lt;img src=&quot;/assets/images/2020/11/VPNConnectionImport-1.gif&quot; alt=&quot;VPN Connection Import&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;What this manual step does is creates the *.PBK file that the VPN client uses to “dial the connection”. Once we have that *.PBK file generated, we can capture the contents, and then deploy it out to other devices via Intune (or Configuration Manager) using a very simple PowerShell script.&lt;/p&gt;

&lt;p&gt;The *.PBK file is stored within the Azure VPN client folder structure in your local app data folder shown below - It’s always the same path which makes all of this very easy to automate!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;%localappdata%\Packages\Microsoft.AzureVpn_8wekyb3d8bbwe\LocalState\rasphone.pbk&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Open the *.pbk file in your favourite editor (that’s VSCode for everyone right?) and let’s move onto the code.&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot; title=&quot;Deploy and configure VPN&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;
#region Configuration
$VPNName = 'Powers Hell VPN Connection'
$VPNGUID = 'F3910F5AC434944F9335C187D7476DB4'
$currentUser = (Get-CimInstance -ClassName WIn32_Process -Filter 'Name=&quot;explorer.exe&quot;' | Invoke-CimMethod -MethodName GetOwner)[0]
$objUser = New-Object System.Security.Principal.NTAccount($currentUser.user)
$strSID = $objUser.Translate([System.Security.Principal.SecurityIdentifier])
$requiredFolder = &quot;C:\Users\$($currentUser.user)\AppData\Local\Packages\Microsoft.AzureVpn_8wekyb3d8bbwe\LocalState&quot;
$rasManKeyPath = &quot;HKLM:\SYSTEM\CurrentControlSet\Services\RasMan\Config&quot; 
#endregion
#region PBK Configuration
$PBKConfig - @&quot;
#Place your PBK contents here...
&quot;@
#endregion
#region Functions
function Write-Log {
    [cmdletbinding()]
    param (
        [string]$logMessage
    )
    Write-Host &quot;[$(Get-Date -Format 'dd-MM-yyyy_HH:mm:ss')] $logMessage&quot; -ForegroundColor Yellow
}
#endregion
#region Deploy VPN
if (!(Test-Path $RequiredFolder -ErrorAction SilentlyContinue)) {
  New-Item $RequiredFolder -ItemType Directory | Out-Null
  $LogLocation = &quot;$RequiredFolder\NewAzureVPNConnectionLog_$(Get-Date -Format 'dd-MM-yyyy_HH_mm_ss').log&quot;
  Start-Transcript -Path $LogLocation -Force -Append
  
  Write-Log &quot;Required folder $RequiredFolder was created on the machine since it wasn't found.&quot;
  New-Item &quot;$RequiredFolder\rasphone.pbk&quot; -ItemType File | Out-Null
  
  Write-Log &quot;File rasphone.pbk has been created in $RequiredFolder.&quot;
  Set-Content &quot;$RequiredFolder\rasphone.pbk&quot; $PBKConfig
  
  Write-Log &quot;File rasphone.pbk has been populated with configuration details.&quot;
  Stop-Transcript | Out-Null
}
else {
  $LogLocation = &quot;$RequiredFolder\NewAzureVPNConnectionLog_$(Get-Date -Format 'dd-MM-yyyy_HH_mm_ss').log&quot;
  Start-Transcript -Path $LogLocation -Force -Append
  
  Write-Log &quot;Folder $RequiredFolder already exists, that means that Azure VPN Client is already installed.&quot;
  if (!(Test-Path &quot;$RequiredFolder\rasphone.pbk&quot; -ErrorAction SilentlyContinue)) {
    
    Write-Log &quot;File rasphone.pbk doesn't exist in $RequiredFolder.&quot;
    New-Item &quot;$RequiredFolder\rasphone.pbk&quot; -ItemType File | Out-Null
    
    Write-Log &quot;File rasphone.pbk has been created in $RequiredFolder.&quot;
    Set-Content &quot;$RequiredFolder\rasphone.pbk&quot; $PBKConfig
    
    Write-Log &quot;File rasphone.pbk has been populated with configuration details.&quot;
    Stop-Transcript | Out-Null
  }
  else {
    Write-Log &quot;File rasphone.pbk already exists in $RequiredFolder.&quot;
    Rename-Item -Path &quot;$RequiredFolder\rasphone.pbk&quot; -NewName &quot;$RequiredFolder\rasphone.pbk_$(Get-Date -Format 'ddMMyyyy-HHmmss')&quot;    
    
    Write-Log &quot;File rasphone.pbk has been renamed to rasphone.pbk_$(Get-Date -Format 'ddMMyyyy-HHmmss'). This file contains old configuration if it will be required in the future (in case it is, just rename it back to rasphone.pbk).&quot;
    New-Item &quot;$RequiredFolder\rasphone.pbk&quot; -ItemType File | Out-Null
    
    Write-Log &quot;New rasphone.pbk file has been created in $RequiredFolder.&quot;
    Set-Content &quot;$RequiredFolder\rasphone.pbk&quot; $PBKConfig
    
    Write-Log &quot;File rasphone.pbk has been populated with configuration details.&quot;
    Stop-Transcript | Out-Null
  }
}
#endregion&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Not much to be said about the above code - all we are doing is pushing out the contents of the *.PBK file to the correct location on the target machines. There is only one important thing to note - I’ve specifically replaced the name and guid from the *.PBK file with variable names to allow me to set them in the configuration at the top of the script. You don’t need to do that yourself, but it makes the solution a little more “reusable”.&lt;/p&gt;

&lt;p&gt;You can see where they normally appear in the screenshot below (lines 1 &amp;amp; 10).&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/11/image.png&quot; title=&quot;PBK Snippet&quot;&gt;&lt;img src=&quot;/assets/images/2020/11/image.png&quot; alt=&quot;PBK Snippet&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Alright, we’ve deployed the VPN - but it still isn’t automatically connecting. Let’s go and figure that out.&lt;/p&gt;

&lt;p&gt;The key to this solution is found in the registry (as always). The auto connection settings can be found in the local machine hive path shown below.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HKLM:\SYSTEM\CurrentControlSet\Services\RasMan\Config&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/11/image-1.png&quot; title=&quot;VPN Registry&quot;&gt;&lt;img src=&quot;/assets/images/2020/11/image-1.png&quot; alt=&quot;VPN Registry&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;As you can see above, for my corporate VPN connection, we are setting a few key values - namely:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;AutoTriggerDisabledProfilesList&lt;/strong&gt; - A list of VPNs specifically set to not automatically connect (done manually by the user).&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;AutoTriggerProfileEntryName&lt;/strong&gt; - The Name of the VPN connection&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;AutoTriggerProfileGUID&lt;/strong&gt; - The HEX GUID of the VPN connection&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;AutoTriggerProfilePhonebookPath&lt;/strong&gt; - The path to the phonebook file&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;UserSID&lt;/strong&gt; - The SID of the user who has set the automatic connection.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Once we understand what is required to set the connection, all we need to do is fill out the data and store it in the correct registry location!&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot; title=&quot;Connect Automatically&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;
#region Functions
function Convert-HexToByte {
  [cmdletbinding()]
  param (
    [string]$HexString
  )
  $splitString = ($HexString -replace '(..)','$1,').Trim(',')
  [byte[]]$hexified = $splitString.Split(',') | ForEach-Object { &quot;0x$_&quot;}
  return $hexified
}
function Set-ComputerRegistryValues {
  param (
      [Parameter(Mandatory = $true)]
      [array]$RegistryInstance
  )
  try {
      foreach ($key in $RegistryInstance) {
          $keyPath = $key.Path
          if (!(Test-Path $keyPath)) {
              Write-Host &quot;Registry path : $keyPath not found. Creating now.&quot; -ForegroundColor Green
              New-Item -Path $key.Path -Force | Out-Null
              Write-Host &quot;Creating item property: $($key.Name)&quot; -ForegroundColor Green
              New-ItemProperty -Path $keyPath -Name $key.Name -Value $key.Value -Type $key.Type -Force
          }
          else {
              Write-Host &quot;Creating item property: $($key.Name)&quot; -ForegroundColor Green
              New-ItemProperty -Path $keyPath -Name $key.Name -Value $key.Value -Type $key.Type -Force
          }
      }
  }
  catch {
      Throw $_.Exception.Message
  }
}
#endregion
#region Configure Always On
[string[]]$autoDisable = (Get-ItemPropertyValue $rasManKeyPath -Name AutoTriggerDisabledProfilesList) | ForEach-Object { if ($_ -ne $VPNName) { $_ }}
$regKeys = @(
  @{
    Path = $rasManKeyPath
    Name = 'AutoTriggerDisabledProfilesList'
    Value = [string[]]$autoDisable
    Type = 'MultiString'
  }
  @{
    Path = $rasManKeyPath
    Name = 'AutoTriggerProfilePhonebookPath'
    Value = &quot;$RequiredFolder\rasphone.pbk&quot;
    Type = 'String'
  }
  @{
    Path = $rasManKeyPath
    Name = 'AutoTriggerProfileEntryName'
    Value = $VPNName
    Type = 'String'
  }
@{
    Path = $rasManKeyPath
    Name = 'UserSID'
    Value = $sid
    Type = 'String'
  }
@{
    Path = $rasManKeyPath
    Name = 'AutoTriggerProfileGUID'
    Value = [Byte[]](Convert-HexToByte -HexString $VPNGUID)
    Type = 'Binary'
  }
)
Set-ComputerRegistryValues $regKeys
#endregion&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Again, most of this code is quite simple - all we are doing is entering some data into the registry.&lt;/p&gt;

&lt;p&gt;The only interesting thing of interest is how I’m converting the VPN GUID from the phonebook file into the Binary format required - which is done with the function &lt;strong&gt;Convert-HexToByte&lt;/strong&gt; show above - that took me a little longer than I’m willing to admit!&lt;/p&gt;

&lt;p&gt;The other thing to be aware of is that deploying the VPN config can be done either in the User or System context - no admin privileges are required, however due to the registry keys being stored in the HKLM hive, admin privileges will be required to set the “connect automatically” section of this solution.&lt;/p&gt;

&lt;p&gt;That’s it for now - if you’ve got any questions about this solution, please reach out to me on &lt;a href=&quot;https://twitter.com/powers_hell&quot;&gt;twitter&lt;/a&gt;, and as always, the code for this post can be found on my &lt;a href=&quot;https://github.com/tabs-not-spaces/CodeDump/tree/master/AzureVPNAutoConnect&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;— Ben&lt;/p&gt;</content><author><name>Ben</name></author><category term="Azure" /><category term="Intune" /><category term="PowerShell" /><category term="Intune" /><summary type="html">One of my clients recently came to me asking for assistance to set up a new VPN solution. The requirements were quite simple - They were building out an Azure Point-To-Site VPN solution and needed me to come up with a way to deliver the connection to the end user devices.</summary></entry><entry><title type="html">Deploying Universal Print Printers With PowerShell &amp;amp; Intune</title><link href="https://powers-hell.com/2020/10/25/deploying-universal-print-printers-with-powershell-intune/" rel="alternate" type="text/html" title="Deploying Universal Print Printers With PowerShell &amp;amp; Intune" /><published>2020-10-25T05:21:15+00:00</published><updated>2020-10-25T05:21:15+00:00</updated><id>https://powers-hell.com/2020/10/25/deploying-universal-print-printers-with-powershell-intune</id><content type="html" xml:base="https://powers-hell.com/2020/10/25/deploying-universal-print-printers-with-powershell-intune/">&lt;p&gt;Over the last few weeks I’ve been playing with &lt;strong&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/universal-print/fundamentals/universal-print-whatis&quot;&gt;Universal Print&lt;/a&gt;&lt;/strong&gt; - the cloud print solution developed by Microsoft and I honestly can’t praise it enough.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;Configuring the “infrastructure” for the solution took me less than 5 minutes.. Seriously - Grab a license (free during the public preview), install and configure a connector on a device with line-of-sight to your printer and finally set the printer shares in the Azure portal.&lt;/p&gt;

&lt;p&gt;It was so easy I honestly don’t think I need to talk more about it - &lt;a href=&quot;https://docs.microsoft.com/en-us/universal-print/fundamentals/universal-print-getting-started&quot;&gt;the steps are really well documented over on the Microsoft Docs page&lt;/a&gt;, so start there if you haven’t already set things up.&lt;/p&gt;

&lt;p&gt;The one area that needs a little bit of polish is the way that printers get deployed to our end user devices. &lt;a href=&quot;https://docs.microsoft.com/en-us/universal-print/fundamentals/universal-print-intune-tool&quot;&gt;The current solution&lt;/a&gt; offered by Microsoft has two key requirements:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Deploy the &lt;strong&gt;Universal Print printer provisioning tool&lt;/strong&gt; via Intune (as a win32 package)&lt;/li&gt;
  &lt;li&gt;Deploy a CSV file with a list of printers, along with a batch script to deploy the CSV file to a key location.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Once the two packages are deployed, printers will then install on the client devices &lt;strong&gt;upon the next reboot or logon event&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;There’s two things I don’t currently love about this solution and wanted to try and improve:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Is there a way we can make the printers install on the client devices without having to wait for a reboot or a logon event?&lt;/li&gt;
  &lt;li&gt;Can we do this with PowerShell?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The answer to both of these statements was a resounding “of course we can!” What I was surprised to find was how simple it actually was.&lt;/p&gt;

&lt;p&gt;This guide assumes you’ve already configured everything else - licensing, setting up the Universal Print connector etc. If you haven’t done that, go and sort that out.&lt;/p&gt;

&lt;p&gt;Alright, let’s jump in - we are going to deploy this solution as a “proactive remediation” script via Intune, although there is nothing stopping you deploying as a standard PowerShell script, or as a packaged win32 application.&lt;/p&gt;

&lt;h2 id=&quot;detection&quot;&gt;Detection&lt;/h2&gt;

&lt;pre title=&quot;Detection Script&quot; class=&quot;wp-block-code&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;#region printer list
$availablePrinters = @(
    &quot;Printer A&quot;
    &quot;Printer B&quot;
    &quot;Printer C&quot;
    &quot;Printer D&quot;
)
$notFound = 0
#endregion
#region check the printers exist
try {
    foreach ($p in $availablePrinters) {
        if (!(Get-Printer -Name $p -ErrorAction SilentlyContinue)) {
            $notFound ++
        }
    }
}
catch {
    $errorMsg = $_.Exception.Message
}
finally {
    if ($errorMsg) {
        Write-Warning $errorMsg
        exit 1
    }
    else {
        if ($notFound) {
            Write-Warning &quot;$notFound printers not found locally..&quot;
            exit 1
        }
        else {
            Write-Host &quot;All printers detected..&quot;
            exit 0
        }
    }
}
#endregion&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code above is pretty simple, simply list the names of the printers you want to make sure exist on the device - if any of them are missing, they will be flagged and the script will exit with a &lt;strong&gt;non-zero&lt;/strong&gt; exit code, which will alert Intune that the remediation script is required to run.&lt;/p&gt;

&lt;h2 id=&quot;remediation&quot;&gt;Remediation&lt;/h2&gt;

&lt;pre title=&quot;Remediation Script&quot; class=&quot;wp-block-code&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;#region printer list
$availablePrinters = @(
    [pscustomobject]@{
        SharedID   = '2f8aa4d8-8c21-4d37-9506-3da446bcf9ea'
        SharedName = 'Printer A'
        IsDefault  = 'Yes'
    }
    [pscustomobject]@{
        SharedID   = 'c288bc70-8e14-4c5b-9f82-428ecf3ab63a'
        SharedName = 'Printer B'
        IsDefault  = $null
    }
    [pscustomobject]@{
        SharedID   = '478a29db-7bdd-46a7-a75e-e0d61167988c'
        SharedName = 'Printer C'
        IsDefault  = $null
    }
    [pscustomobject]@{
        SharedID   = '896262c5-59ca-4b92-becf-074feb25fccc'
        SharedName = 'Printer D'
        IsDefault  = $null
    }
)
#endregion
try {
    $configurationPath = &quot;$env:appdata\UniversalPrintPrinterProvisioning\Configuration&quot;
    if (!(Test-Path $configurationPath -ErrorAction SilentlyContinue)) {
        New-Item $configurationPath -ItemType Directory -Force | Out-Null
    }
    $printCfg = ($availablePrinters | ConvertTo-Csv -NoTypeInformation | ForEach-Object { $_ -replace '&quot;', &quot;&quot; } ) -join [System.Environment]::NewLine
    $printCfg | Out-File &quot;$configurationPath\printers.csv&quot; -Encoding ascii -NoNewline
    Start-Process &quot;${env:ProgramFiles(x86)}\UniversalPrintPrinterProvisioning\Exe\UPPrinterInstaller.exe&quot; -Wait -WindowStyle Hidden
}
catch {
    $errorMsg = $_.Exception.Message
}
finally {
    if ($errorMsg) {
        Write-Warning $errorMsg
        exit 1
    }
    else {
        Write-Host &quot;Universal Printer Installer configured and launched. Printers should appear shortly..&quot;
        exit 0
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The remediation script is also quite simple, the &lt;strong&gt;$availablePrinters&lt;/strong&gt; array contains the details of each Universal Print printer that we need to map the printer to the device.&lt;/p&gt;

&lt;p&gt;Head to &lt;strong&gt;Universal Print &amp;gt; Printer Shares&lt;/strong&gt; (In the Azure portal), select each printer share and make note of the &lt;strong&gt;Share ID&lt;/strong&gt; and the &lt;strong&gt;Name&lt;/strong&gt; of the share. For each printer, you will create a &lt;strong&gt;psCustomObject&lt;/strong&gt; containing the &lt;strong&gt;ShareID, SharedName&lt;/strong&gt; and whether or not you want this printer to be flagged as a &lt;em&gt;default&lt;/em&gt; printer or not.&lt;figure class=&quot;wp-block-image size-full&quot;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/10/image-1.png&quot; title=&quot;Printer A&quot;&gt;&lt;img src=&quot;/assets/images/2020/10/image-1.png&quot; alt=&quot;Printer A&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The rest of the script is also fairly straight forward. What we are doing is building out the “printers.csv” file that the &lt;strong&gt;Universal Print Printer Provisioning Service&lt;/strong&gt; uses to validate which printers to install.&lt;/p&gt;

&lt;p&gt;The real &lt;em&gt;magic&lt;/em&gt; of the script (which isn’t really that magic) is on line 32. The print provisioning service that gets installed by the Universal Print installation media sits in the background and listens for a &lt;strong&gt;user logon&lt;/strong&gt; event. Once this event is found, the service triggers another executable - &lt;strong&gt;UPPrinterInstaller.exe&lt;/strong&gt; which looks for the *.csv file we have created, authenticates to Graph, validates the print share details and then kicks off a &lt;strong&gt;Web Services for Devices (WSD)&lt;/strong&gt; process to map the available printers.&lt;/p&gt;

&lt;p&gt;Now, I’ll be the first to admit that the solution here is a little “kludgy” - I initially intended to reverse engineer the &lt;strong&gt;UPPrinterInstaller.exe&lt;/strong&gt; to identify exactly &lt;em&gt;how&lt;/em&gt; that WSD process works, however this works well enough - for now at least.&lt;/p&gt;

&lt;h2 id=&quot;notes&quot;&gt;Notes&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;the Proactive Remediation detection and remediation scripts need to be run in the &lt;strong&gt;user context&lt;/strong&gt; as opposed to system - make sure you set that in the solution.&lt;/li&gt;
  &lt;li&gt;The default printer value will &lt;strong&gt;NOT&lt;/strong&gt; work the way it is intended if you have the &lt;strong&gt;Let Windows manage my default printer&lt;/strong&gt; setting enabled (found within the &lt;strong&gt;Printers &amp;amp; scanners&lt;/strong&gt; section of settings). Which makes sense - but just be aware of that.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I will continue to dig into this solution to try and make it a little more elegant - with the hopes that any advancements I make with the provisioning process might just make it into the official solution once it leaves Public Preview.&lt;/p&gt;

&lt;p&gt;As always, the code referenced in this guide is available in &lt;a href=&quot;https://github.com/tabs-not-spaces/CodeDump/tree/master/Universal-Print-Printer-Install&quot;&gt;GitHub&lt;/a&gt; and I can be reached on &lt;a href=&quot;https://twitter.com/powers_hell&quot;&gt;Twitter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;— Ben&lt;/p&gt;</content><author><name>Ben</name></author><category term="Azure" /><category term="Graph" /><category term="Intune" /><category term="PowerShell" /><category term="Universal Print" /><category term="Intune" /><category term="PowerShell" /><category term="Universal Print" /><summary type="html">Over the last few weeks I've been playing with **Universal Print** - the cloud print solution developed by Microsoft and I honestly can't praise it enough.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://powers-hell.com/assets/images/2020/10/universalprint.gif" /><media:content medium="image" url="https://powers-hell.com/assets/images/2020/10/universalprint.gif" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Preparing custom image templates with Azure Image Builder &amp;amp; PowerShell</title><link href="https://powers-hell.com/2020/09/20/preparing-custom-image-templates-with-azure-image-builder-powershell/" rel="alternate" type="text/html" title="Preparing custom image templates with Azure Image Builder &amp;amp; PowerShell" /><published>2020-09-20T10:44:14+00:00</published><updated>2020-09-20T10:44:14+00:00</updated><id>https://powers-hell.com/2020/09/20/preparing-custom-image-templates-with-azure-image-builder-powershell</id><content type="html" xml:base="https://powers-hell.com/2020/09/20/preparing-custom-image-templates-with-azure-image-builder-powershell/">&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/azure/virtual-machines/windows/image-builder-overview&quot;&gt;Azure Image Builder&lt;/a&gt; (AIB) is Microsoft’s solution to configure and customize virtual machine images. The concept of it is pretty great: Pick a reference image from the public market place, apply some customization built around &lt;a href=&quot;https://www.packer.io/&quot;&gt;HashiCorp’s Packer&lt;/a&gt;, hit build and what you are left with is a fully customized template image that can be hosted in Azure as a managed image or a VHD file.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;Now, here’s the problem - AIB is still very much in preview and is tricky to set up. There’s lots of &lt;a href=&quot;http://xenithit.blogspot.com/2020/06/using-azure-image-builder-and-azure.html&quot;&gt;great guides&lt;/a&gt; on how to set up your tenant to use AIB, but I wanted to try and simplify the initial configuration of your tenant so you can get past the “preview hurdles” and just get straight into building your image templates.&lt;/p&gt;

&lt;p&gt;So, I went and published a “helper” module to do just that! &lt;a href=&quot;https://www.powershellgallery.com/packages/az.imagebuilder.tools&quot;&gt;Az.ImageBuilder.Tools&lt;/a&gt; is a module that will assist you with configuring your tenant to enable the features, custom roles and managed identities required to start playing with AIB.&lt;/p&gt;

&lt;p&gt;Let’s dive right in - by the end of this guide, we will be able to:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Set up our tenant to use AIB and Shared Image Gallery (SIB)&lt;/li&gt;
  &lt;li&gt;Build the AIB template from the Win10 EVD (multi session) image from the Azure Marketplace&lt;/li&gt;
  &lt;li&gt;Add a customization script to pre-install software to our AIB template&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All right - let’s get into it!&lt;/p&gt;

&lt;h2 id=&quot;pre-requirements&quot;&gt;Pre-Requirements&lt;/h2&gt;

&lt;h3 id=&quot;grab-the-modules&quot;&gt;Grab the modules&lt;/h3&gt;

&lt;p&gt;First, let’s install the &lt;a href=&quot;https://www.powershellgallery.com/packages/az.imagebuilder.tools&quot;&gt;Az.ImageBuilder.Tools&lt;/a&gt; module - this will not only install my helper module, but all other required pre-req modules.&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;Install-Module Az.ImageBuilder.Tools&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;authenticate-to-your-tenant&quot;&gt;Authenticate to your tenant&lt;/h3&gt;

&lt;p&gt;Make sure you are connected to your tenant!&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;
#region Connect to Azure
Connect-AzAccount
$azContext = Get-AzContext
$subscriptionID = $azContext.Subscription.Id
#endregion
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;enable-the-features-and-providers-required-for-aib--sig&quot;&gt;Enable the features and providers required for AIB / SIG&lt;/h3&gt;

&lt;p&gt;This one is going to take a minute - run the below command and check back in 15..&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;Invoke-AIBProviderCheck&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run the same command in 15~ minutes to verify the features and providers are registered. If you don’t want to do this step, add &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-wait&lt;/code&gt; to the command. Once everything is ready, you should see the below.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/09/invoke-aibprovidercheck.gif&quot; title=&quot;Imvoke-AIBProvider&quot;&gt;&lt;img src=&quot;/assets/images/2020/09/invoke-aibprovidercheck.gif&quot; alt=&quot;Imvoke-AIBProvider&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;define-the-variables&quot;&gt;Define the variables&lt;/h2&gt;

&lt;p&gt;You don’t need to set these up, but c’mon - this guide is clearly setting you up for an automated template process… so let’s go ahead and treat it like that.&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;$resourceGroupName = 'AIB-ResourceGroup'
$location = 'eastus'
$imageTemplateName = 'Win10-20H1-EVD'
$sharedGalleryName = 'SharedImageGallery'
$imageDefinitionName = 'Win10EVD'
$runOutputName = 'winClientR01'
$imageConfig = @{
    OsState   = 'generalized'
    OsType    = 'Windows'
    Publisher = 'MicrosoftWindowsDesktop'
    Offer     = 'office-365'
    Sku       = '20h1-evd-o365pp'
    Version   = 'latest'
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A few notes on the variables above:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The values in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$imageConfig&lt;/code&gt; are set specifically for the current build of the Win10 EVD image from the marketplace - don’t change those unless you know there is a new version.&lt;/li&gt;
  &lt;li&gt;Everything else is fair game - &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$resourceGroupName&lt;/code&gt; defines the name of the resource group you want to put the AIB / SIG resources into - if it doesn’t exist, don’t worry - the next step will sort that out.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;initialize-azure-image-builder-aib&quot;&gt;Initialize Azure Image Builder (AIB)&lt;/h2&gt;

&lt;p&gt;Now we need to create the custom roles and managed identity - these are the steps that stop most people from moving ahead - no worry, I’ve sorted it out.&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;$mIDParams = @{
    AzureContext      = $azContext
    ResourceGroupName = $resourceGroupName
    Location          = $location
    IdentityName      = 'aibIdentity'
}
$managedIdentity = Initialize-AzureImageBuilder @mIDParams&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This command will create the resource group if its missing, create a managed identity and apply custom roles required to work with AIB / SIG.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/09/initialize-azureImageBuilder.gif&quot; title=&quot;Initializa-AzureImageBuilder&quot;&gt;&lt;img src=&quot;/assets/images/2020/09/initialize-azureImageBuilder.gif&quot; alt=&quot;Initializa-AzureImageBuilder&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;create-the-shared-image-gallery-sig&quot;&gt;Create the Shared Image Gallery (SIG)&lt;/h2&gt;

&lt;p&gt;AIB allows us to host our image templates as VHDs or in a &lt;a href=&quot;https://docs.microsoft.com/en-us/azure/virtual-machines/windows/shared-image-galleries&quot;&gt;Shared Image Gallery&lt;/a&gt; - I won’t go into what SIG is here, but for the sake of clarity - SIG is a great solution to store and manage image templates.&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;$azGalleryParams = @{
    Name              = $sharedGalleryName
    ResourceGroupName = $resourceGroupName
    Location          = $location
}
New-AzGallery @azGalleryParams&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;prepare-the-source-image&quot;&gt;Prepare the source image&lt;/h2&gt;

&lt;p&gt;Ok, we are going to set up the source image and the definitions - nothing too exciting here. The commands and their parameters should be self-explanatory.&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;# create the source image
$srcObjParams = @{
    SourceTypePlatformImage = $true
    Publisher               = $imageConfig.Publisher
    Offer                   = $imageConfig.Offer
    Sku                     = $imageConfig.Sku
    Version                 = $imageConfig.Version
}
$srcPlatform = New-AzImageBuilderSourceObject @srcObjParams
# create the image definition
$imageDefParams = @{
    GalleryName       = $sharedGalleryName
    ResourceGroupName = $resourceGroupName
    Location          = $location
    Name              = $imageDefinitionName
    OsState           = $imageconfig.OsState
    OsType            = $imageConfig.OsType
    Publisher         = ([mailaddress]$azContext.account.id).Host
    Offer             = $imageConfig.Offer
    Sku               = $imageConfig.Sku
}
New-AzGalleryImageDefinition @imageDefParams
# create the distributor object
$distObjParams = @{
    SharedImageDistributor = $true
    ArtifactTag            = @{ tag = 'dis-share' }
    GalleryImageId         = &quot;/subscriptions/$subscriptionID/resourceGroups/$resourceGroupName/providers/Microsoft.Compute/galleries/$sharedGalleryName/images/$imageDefinitionName&quot;
    ReplicationRegion      = $location
    RunOutputName          = $runOutputName
    ExcludeFromLatest      = $false
}
$disSharedImg = New-AzImageBuilderDistributorObject @distObjParams&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;add-customization&quot;&gt;Add customization&lt;/h2&gt;

&lt;p&gt;Here’s the secret sauce - you can add as many customization objects as you want to this. It’s documented well - go check it out. But for now, I’ve hosted a simple PowerShell script on GitHub and I’m going to use that as my single customization step.&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;# Add customizer step
$imgCustomParams = @{
    PowerShellCustomizer = $true
    CustomizerName       = 'MountAppShareAndRunInstaller'
    RunElevated          = $true
    scriptUri            = 'https://raw.githubusercontent.com/tabs-not-spaces/Az.ImageBuilder.Tools/master/Samples/AppInstall.ps1'
}
$customizer = New-AzImageBuilderCustomizerObject @imgCustomParams&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;combine-all-the-ingredients&quot;&gt;Combine all the ingredients..&lt;/h2&gt;

&lt;p&gt;Now we have our shared image gallery, source object, distributor object, image definition and customization steps - let’s add them all together and prep the template.&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;# Create AIB Template
$imgTemplateParams = @{
    ImageTemplateName      = $imageTemplateName
    ResourceGroupName      = $resourceGroupName
    Source                 = $srcPlatform
    Distribute             = $disSharedImg
    Customize              = $customizer
    Location               = $location
    UserAssignedIdentityId = $managedIdentity.ResourceId
}
New-AzImageBuilderTemplate @ImgTemplateParams&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is going to take a little while - around 10 minutes. Keep an eye on the status of the task with the following command.&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;Get-AzImageBuilderTemplate -ImageTemplateName $imageTemplateName -ResourceGroupName $resourceGroupName&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;build-the-template&quot;&gt;Build the template&lt;/h2&gt;

&lt;p&gt;Everything is ready - now we just need to kick off the build - again, this is going to take a while. From my experience, I’ve found it takes anywhere from 15 minutes to an Hour - it entirely depends on what customization options you are adding.&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;# Start the template build task
# check back on the $job variable for the build status
$job = Start-AzImageBuilderTemplate -ResourceGroupName $resourceGroupName -Name $imageTemplateName -AsJob&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If your customization script stalls or is written in a way that can’t bomb out elegantly, you may find yourself in a situation where the build process stalls - the image builder template process will time out after 4 hours by default. This can be changed.&lt;/p&gt;

&lt;p&gt;While this step is running, you can monitor the process in one of 3 ways.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;check on the status of the $job variable - while it’s running it’ll advise you. Same for when it’s completed.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/09/start-azimagebuildertemplate.gif&quot; title=&quot;Start-AzImageBuilderTemplate&quot;&gt;&lt;img src=&quot;/assets/images/2020/09/start-azimagebuildertemplate.gif&quot; alt=&quot;Start-AzImageBuilderTemplate&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Check the build status directly from the AIB API&lt;/li&gt;
&lt;/ul&gt;

&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;Get-AIBBuildStatus -AzureContext $azContext -ResourceGroupName $resourceGroupName -ImageTemplateName $imageTemplateName&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/09/get-aibbuildstatus.gif&quot; title=&quot;Get-AIBBuildStatus&quot;&gt;&lt;img src=&quot;/assets/images/2020/09/get-aibbuildstatus.gif&quot; alt=&quot;Get-AIBBuildStatus&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Finally, you can check the &lt;strong&gt;VERY&lt;/strong&gt; verbose logs of packer - jump into your resource groups list - you’ll see a new resource group similarly named to the resource group you defined at the start of this guide.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/09/image-1.png&quot; title=&quot;AIB Resource Group&quot;&gt;&lt;img src=&quot;/assets/images/2020/09/image-1.png&quot; alt=&quot;AIB Resource Group&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Inside the storage account, there will be a container named &lt;strong&gt;packerlogs.&lt;/strong&gt; click through the packerlogs container and the internal randomly generated folder and monitor the &lt;strong&gt;customization.log&lt;/strong&gt; file. There’s &lt;a href=&quot;https://docs.microsoft.com/en-us/azure/virtual-machines/linux/image-builder-troubleshoot#customization-log&quot;&gt;good documentation&lt;/a&gt; on this, and it’s going to help you out if you need to troubleshoot your customization script.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Once your template is built - you are done! You now have a customized template that you can use to build out virtual machines… or if you are paying attention - session hosts for Windows Virtual Desktop!&lt;/p&gt;

&lt;p&gt;Stay tuned for a post on how to build WVD session hosts using AIB and PowerShell!&lt;/p&gt;

&lt;p&gt;As always, sample code used in this guide are available on &lt;a href=&quot;https://github.com/tabs-not-spaces/Az.ImageBuilder.Tools/tree/master/Samples&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;— Ben&lt;/p&gt;</content><author><name>Ben</name></author><category term="Azure" /><category term="PowerShell" /><category term="Automation" /><category term="WVD" /><category term="Azure Image Builder" /><category term="PowerShell" /><category term="Automation" /><category term="WVD" /><summary type="html">AIB is Microsoft's solution to configure and customize virtual machine images. The concept of it is pretty great.. pick a reference image from the public market place apply some customization built around HashiCorp's Packer hit build and what you are left with is a fully customized template image that can be hosted in Azure as a managed image or a VHD file.</summary></entry><entry><title type="html">Dynamically set the time zone of a device in Intune using Azure Maps &amp;amp; PowerShell</title><link href="https://powers-hell.com/2020/08/31/setting-the-time-zone-of-an-intune-managed-device-using-azure-maps-powershell/" rel="alternate" type="text/html" title="Dynamically set the time zone of a device in Intune using Azure Maps &amp;amp; PowerShell" /><published>2020-08-30T21:20:59+00:00</published><updated>2020-08-30T21:20:59+00:00</updated><id>https://powers-hell.com/2020/08/31/setting-the-time-zone-of-an-intune-managed-device-using-azure-maps-powershell</id><content type="html" xml:base="https://powers-hell.com/2020/08/31/setting-the-time-zone-of-an-intune-managed-device-using-azure-maps-powershell/">&lt;p&gt;Let me start off by saying I wish I didn’t have to write this post. Setting the correct time zone of a Windows device shouldn’t be this difficult, especially with all of the management possibilities provided to us with Intune and the entire endpoint management stack. But here we are!&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;I get it though. At one point, as &lt;a href=&quot;https://twitter.com/mniehaus&quot;&gt;Michael Neihaus&lt;/a&gt; &lt;a href=&quot;https://oofhours.com/2019/12/20/configuring-time-zones-part-2/&quot;&gt;has written about previously&lt;/a&gt;, even if we could configure the time zone during the Out of Box Experience, everything was hinged on the timings of certificates and policies reaching the device within an agreed time frame.
If the time zone changed on a device during that process it had the possibility to break the entire enrollment process. This has since been (for the most part) resolved if you are using Windows 10 2004 (20h1) as your operating system.&lt;/p&gt;

&lt;p&gt;I’m hopeful that eventually, we will be able to configure the time zone as part of the OOBE, but until that time comes, I’d like to share some ways that I currently solve this problem using Azure Maps &amp;amp; PowerShell.&lt;/p&gt;

&lt;p&gt;Most solutions I’ve found involve creating custom OMA-URI policies to set the value of the time zone which works in some scenarios, but isn’t elegant enough to handle the real world problem of managing devices and users located all over the world. So let’s change that.&lt;/p&gt;

&lt;h2 id=&quot;setting-time-zone-from-device-gps-data&quot;&gt;Setting time zone from device GPS data&lt;/h2&gt;

&lt;p&gt;This one is fun but does require that &lt;strong&gt;location services&lt;/strong&gt; are turned on which, by default are disabled. This can be enforced by device configuration policies, but there are obvious security implications and you may need to discuss this with your organization before enabling.&lt;/p&gt;

&lt;p&gt;The solution below converts the GPS latitude and longitude data to the required windows time zone data by using an API available through Azure Maps.&lt;/p&gt;

&lt;p&gt;Pricing is super affordable and the “included free quantity” means that for small to medium-sized businesses, there is a chance you’d end up not paying a cent. For reference, here are the available &lt;a href=&quot;https://docs.microsoft.com/en-us/azure/azure-maps/choose-pricing-tier&quot;&gt;plans&lt;/a&gt; and &lt;a href=&quot;https://azure.microsoft.com/en-us/pricing/details/azure-maps/&quot;&gt;pricing&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;configuring-azure-maps&quot;&gt;Configuring Azure Maps&lt;/h3&gt;

&lt;p&gt;This is super easy, but it’s still worth documenting!&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Open up your Azure portal and create a new resource.&lt;/li&gt;
  &lt;li&gt;Search the marketplace for “Azure Maps” and create an account.&lt;/li&gt;
  &lt;li&gt;Fill out the relevant fields and choose your pricing tier (as mentioned above, S0 will be &lt;strong&gt;more&lt;/strong&gt; than enough for this demo.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/08/image-4.png&quot; title=&quot;Create Azure Maps Account&quot;&gt;&lt;img src=&quot;/assets/images/2020/08/image-4.png&quot; alt=&quot;Create Azure Maps Account&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Once the account is created, go to the resource and head to the &lt;strong&gt;Authentication&lt;/strong&gt; page. Make note of one of the &lt;strong&gt;Shared Keys&lt;/strong&gt;. We will use these to authenticate to the service.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;writing-the-code&quot;&gt;Writing the code&lt;/h3&gt;

&lt;p&gt;Now let’s grab our GPS data and send it to the Azure Maps API!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;Add-Type -AssemblyName System.Device
$gw = New-Object System.Device.Location.GeoCoordinateWatcher
$gw.Start()
while (($gw.Status -ne 'Ready') -and ($gw.Permission -ne 'Denied')) {
    Start-Sleep -Milliseconds 100 #Wait for discovery.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above code is fairly simple - we are adding the &lt;strong&gt;System.Device&lt;/strong&gt; assembly to our session and creating and starting a new &lt;strong&gt;GeoCoordinateWatcher&lt;/strong&gt; object to capture the GPS data of our device.&lt;/p&gt;

&lt;p&gt;If we look at the results that are stored in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$gw&lt;/code&gt; variable we should see the property name &lt;strong&gt;Permission&lt;/strong&gt;. If we step into that, we should see the location data required for the next step.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/08/image-5.png&quot; title=&quot;$gw variable&quot;&gt;&lt;img src=&quot;/assets/images/2020/08/image-5.png&quot; alt=&quot;$gw variable&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Now that we have our Latitude and Longitude data stored in a variable, next we need to form the request to the Azure Maps API.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;$apiKey = &quot;00000000000000000000000000&quot; #replace with your subscription Key
$baseUri = &quot;https://atlas.microsoft.com/timezone&quot;
$restParams = @{
    Method      = &quot;Get&quot;
    Uri         = &quot;$baseUri/byCoordinates/json?subscription-key=$apiKey&amp;amp;api-version=1.0&amp;amp;query=$($gw.Position.Location.Latitude),$($gw.Position.Location.Longitude)&quot;
    ContentType = 'Application/Json'
}
$locData = Invoke-RestMethod @restParams
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Looking at the contents of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$locData&lt;/code&gt; we should now see some cool data.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/08/image-6.png&quot; title=&quot;location data&quot;&gt;&lt;img src=&quot;/assets/images/2020/08/image-6.png&quot; alt=&quot;location data&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Stepping into the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$locData.TimeZones&lt;/code&gt; property should give us even more info.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/08/image-7.png&quot; title=&quot;Timezones data&quot;&gt;&lt;img src=&quot;/assets/images/2020/08/image-7.png&quot; alt=&quot;Timezones data&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The final step is to convert the value we see in &lt;strong&gt;Id&lt;/strong&gt; from the IANA code, to the format our computer needs to set the time zone.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;$apiKey = '000000000000000000000000000000' #use a subscription key from your Azure Maps Account
$restParams = @{
    Method = 'Get'
    Uri = &quot;https://atlas.microsoft.com/timezone/enumWindows/json?subscription-key=$apiKey&amp;amp;api-version=1.0&quot;
    ContentType = 'Application/Json'
}
$tzList = Invoke-RestMethod @restParams
$result = $tzList | Where-Object { $locData.TimeZones.id -in $_.IanaIds }
Set-TimeZone -Id $result
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All we are doing above is getting a list of Windows time zone IDs and matching them to the IANA time zone ID. Once we have a match, using the native &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Set-TimeZone&lt;/code&gt; allows us to dynamically set our device time zone with relative ease!&lt;/p&gt;

&lt;h2 id=&quot;setting-time-zone-from-public-ip-address&quot;&gt;Setting Time Zone from public IP address&lt;/h2&gt;

&lt;p&gt;So what if you aren’t allowed to enable location services? Or what if you are provisioning virtual machines that don’t have access to the GPS data? Luckily, there is another way to get our location data - from the publicly facing IP address of the device.&lt;/p&gt;

&lt;p&gt;For this example, we will use a free API from &lt;a href=&quot;https://ipinfo.io&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://ipinfo.io/&quot;&gt;https://ipinfo.io&lt;/a&gt;. You can use this API without registering, however, it is heavily rate-limited without providing an access token, so just register an account - it allows 50,000 API calls a month for free which is more than enough for this scenario.&lt;/p&gt;

&lt;p&gt;Once you’ve registered and signed in, grab a copy of the access token from the dashboard - we will use it below.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;$apiKey = '000000000000000000000000000000' # replace with access key from your ipinfo.io account
$locData = Invoke-RestMethod &quot;https://ipinfo.io?token=$apiKey&quot; -ContentType 'Application/Json'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we look at the value of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$locData&lt;/code&gt; we should see similar data from our first example.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/08/image-9.png&quot; title=&quot;$locData&quot;&gt;&lt;img src=&quot;/assets/images/2020/08/image-9.png&quot; alt=&quot;$locData&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Jackpot! The value of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$locData.timezone&lt;/code&gt; is a properly formatted IANA Id. We could reuse the code from the first example to match up the IANA Id to the Windows time zone Id - or we can save an API call and grab a copy of the results and compare them in the code. Let’s see how that would look.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;$tzList = @{
    #region snippet of the countr / iana code table
    &quot;Africa/Abidjan&quot;      = &quot;Greenwich Standard Time&quot;
    &quot;Africa/Accra&quot;        = &quot;Greenwich Standard Time&quot;
    &quot;Africa/Addis_Ababa&quot;  = &quot;E. Africa Standard Time&quot;
    &quot;Africa/Algiers&quot;      = &quot;W. Central Africa Standard Time&quot;
    &quot;Africa/Asmera&quot;       = &quot;E. Africa Standard Time&quot;
    &quot;Africa/Bamako&quot;       = &quot;Greenwich Standard Time&quot;
    &quot;Africa/Bangui&quot;       = &quot;W. Central Africa Standard Time&quot;
    &quot;Africa/Banjul&quot;       = &quot;Greenwich Standard Time&quot;
    &quot;Africa/Bissau&quot;       = &quot;Greenwich Standard Time&quot;
    &quot;Africa/Blantyre&quot;     = &quot;South Africa Standard&quot;
    #endregion
}
$windowsId = $tzList.Get_Item($locData.timezone)
if ($windowsId) {
    $result = $windowsId
}
else {
    $result = ($tzList.GetEnumerator() | Where-Object { $_.Key -like &quot;*$($locData.timezone)*&quot; }).Value
}
Write-Host &quot;Setting timezone to $result..&quot;
Set-TimeZone -Id $result
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Obviously, that’s a LOT more code (cut for readability), but it does save us another API call, which if we are deploying to tens of thousands of devices could in the end save us being charged for API use!&lt;/p&gt;

&lt;p&gt;I personally prefer and actually do use the second method for setting time zones as during my testing I’m invariably building VMs before I move to physical devices (sometimes I don’t even end up onto physical devices!), so being able to get a rough estimate of the location-based on public IP is much more reliable.&lt;/p&gt;

&lt;p&gt;How you deploy this to your devices is up to personal preference and operational requirements of course. I’ve generally had success simply deploying as a configuration script where I am happy for it to only run once, however bundling this with a scheduled task to run once a week or once a month to maintain time zone reliability is another great option.&lt;/p&gt;

&lt;p&gt;I’ve polished up the code from this article and provided both solutions as ready to deploy scripts, go check them out on my &lt;a href=&quot;https://github.com/tabs-not-spaces/CodeDump/tree/master/Set-Timezone&quot;&gt;GitHub&lt;/a&gt; - just make sure to update the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$apiKey&lt;/code&gt; for either scenario you choose to utilize.&lt;/p&gt;

&lt;p&gt;— Ben&lt;/p&gt;</content><author><name>Ben</name></author><category term="Azure" /><category term="Intune" /><category term="PowerShell" /><category term="Intune" /><summary type="html">Let me start off by saying I wish I didn’t have to write this post. Setting the correct time zone of a Windows device shouldn’t be this difficult, especially with all of the management possibilities provided to us with Intune and the entire endpoint management stack. But here we are!</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://powers-hell.com/assets/images/2020/08/gpsdata.jpg" /><media:content medium="image" url="https://powers-hell.com/assets/images/2020/08/gpsdata.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Managing Intune with Graph, PowerShell 7 &amp;amp; MSAL</title><link href="https://powers-hell.com/2020/06/28/managing-intune-with-graph-powershell-7-msal/" rel="alternate" type="text/html" title="Managing Intune with Graph, PowerShell 7 &amp;amp; MSAL" /><published>2020-06-27T22:39:24+00:00</published><updated>2020-06-27T22:39:24+00:00</updated><id>https://powers-hell.com/2020/06/28/managing-intune-with-graph-powershell-7-msal</id><content type="html" xml:base="https://powers-hell.com/2020/06/28/managing-intune-with-graph-powershell-7-msal/">&lt;p&gt;So it seems we need to talk about Graph and authentication again..&lt;/p&gt;

&lt;p&gt;Recently, Microsoft announced an official &lt;a href=&quot;https://techcommunity.microsoft.com/t5/azure-active-directory-identity/update-your-applications-to-use-microsoft-authentication-library/ba-p/1257363&quot;&gt;“end of support timeline” for Azure Active Directory Authentication Library (ADAL)&lt;/a&gt; which means, any scripts or automation workflows that you use will need to be migrated over to the newer Microsoft Authentication Libraries (MSAL).&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;There are many differences between the two libraries, but the workflows are very similar - a request is sent using the libraries for access to specific areas of Azure and an authentication token is sent back giving you the keys into your Azure tenant.&lt;/p&gt;

&lt;p&gt;While the announcement from Microsoft gives us a few years to move on, right now if you have moved your workloads over to PowerShell 7 (which you 100% should be), you may have noticed that working with ADAL is tricky.&lt;/p&gt;

&lt;p&gt;Lets have a look at that now - using &lt;a href=&quot;https://twitter.com/davefalkus&quot;&gt;Dave’s&lt;/a&gt; &lt;a href=&quot;https://github.com/microsoftgraph/powershell-intune-samples/blob/master/LOB_Application/Win32_Application_Add.ps1&quot;&gt;sample code&lt;/a&gt;, let’s try and authenticate using the “well-known” Intune application in PowerShell 7.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/06/adalauthPS7.gif&quot; title=&quot;failing authentication in pwsh7&quot;&gt;&lt;img src=&quot;/assets/images/2020/06/adalauthPS7.gif&quot; alt=&quot;failing authentication in pwsh7&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;And for reference, the same code in PowerShell 5.1.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/06/adalauthPS5.gif&quot; title=&quot;passing auth in pwsh5.1&quot;&gt;&lt;img src=&quot;/assets/images/2020/06/adalauthPS5.gif&quot; alt=&quot;passing auth in pwsh5.1&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The primary issue here is that PowerShell 7 just doesn’t natively support the old authentication libraries - you can work around it if you have your existing authentication scripts in a module that you import using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-UseWindowsPowerShell&lt;/code&gt; compatibility flag, but that’s not an ideal scenario.&lt;/p&gt;

&lt;p&gt;So how do we authenticate successfully in PowerShell 7 then? With MSAL of course!&lt;/p&gt;

&lt;p&gt;For simplicities sake, I will not deep dive into manually creating MSAL requests, as luckily there is already a great module available to us on the PowerShell Gallery - &lt;a href=&quot;https://www.powershellgallery.com/packages/MSAL.PS&quot;&gt;MSAL.PS&lt;/a&gt; (Written by &lt;a href=&quot;https://github.com/jasoth&quot;&gt;Jason Thompson&lt;/a&gt;). So Let’s go ahead and install that on our computer.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;Install-Module MSAL.PS -Scope CurrentUser
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One of the benefits of MSAL is that it has been designed from the ground up to be completely cross-platform compatible, which means we get a few new ways to authenticate to devices that are “input constrained”. This is called “device code flow”.&lt;/p&gt;

&lt;p&gt;Using the well-known Intune app id, lets try out Device Code Flow.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;Get-MsalToken -ClientId 'd1ddf0e4-d672-4dae-b554-9d5bdfd93547' -TenantId 'powers-hell.com' -DeviceCode
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/06/msalDeviceCode.gif&quot; title=&quot;device code flow&quot;&gt;&lt;img src=&quot;/assets/images/2020/06/msalDeviceCode.gif&quot; alt=&quot;device code flow&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This is pretty cool - adding &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-DeviceCode&lt;/code&gt; to our command generates a code that we can use on another device to authenticate “on behalf of” the initial requesting device.&lt;/p&gt;

&lt;p&gt;But what if we want to keep it “old school” ? Can we just interactively authenticate?&lt;/p&gt;

&lt;p&gt;The answer to that is “Yes. But not with the well-known Intune app id..”&lt;/p&gt;

&lt;p&gt;Let’s try it now..&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;Get-MsalToken -ClientId 'd1ddf0e4-d672-4dae-b554-9d5bdfd93547' -TenantId 'powers-hell.com' -DeviceCode
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/06/msalInteractiveFail.gif&quot; title=&quot;failing interactive auth&quot;&gt;&lt;img src=&quot;/assets/images/2020/06/msalInteractiveFail.gif&quot; alt=&quot;failing interactive auth&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;How annoying! But what does this error mean?&lt;/p&gt;

&lt;p&gt;Simply put, the reply URLs in the AAD application we went to try and authenticate are missing the specific reply URL that MSAL needs registered, which is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://localhost&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So, what this means, is that until the maintainer of the “PowerShell Intune” application updates the app to include the correct scope, the only way we can use it with MSAL is by following the device code flow.&lt;/p&gt;

&lt;p&gt;Until that time, we can create our own AAD application with the same permissions contained within the well-known app and use that instead.&lt;/p&gt;

&lt;p&gt;For those interested in this, the permissions required are below.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;Intune Client Scope:&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;DeviceManagementApps.ReadWrite.All&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DeviceManagementConfiguration.ReadWrite.All&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DeviceManagementManagedDevices.PrivilegedOperations.All&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DeviceManagementManagedDevices.ReadWrite.All&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DeviceManagementRBAC.ReadWrite.All&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DeviceManagementServiceConfig.ReadWrite.All&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Directory.Read.All Group.Read.All&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Group.ReadWrite.All&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;I’ve already gone ahead and created this in my tenant and will be using it for all of my existing workflows and tools.&lt;/p&gt;

&lt;p&gt;So now we have a new AAD application registered with the correct permission scopes AND the correct reply URL, let’s see the authentication flow in a simple Graph call.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;[cmdletbinding()]
param (
    [Parameter(Mandatory = $true)]
    [guid]$clientId,

    [Parameter(Mandatory = $true)]
    [string]$tenantId
)
#region Get the auth token and build the auth header
$auth = Get-MsalToken -ClientId $clientId -TenantId $tenantId -Interactive
$authHeader = @{Authorization = $auth.CreateAuthorizationHeader()}
#endregion

#region Build the request and return the ID and Name of all win32 apps
$baseGraphUri = &quot;https://graph.microsoft.com/beta/deviceappmanagement/mobileapps&quot;
$results = (Invoke-RestMethod -Method Get -Uri &quot;$baseGraphUri`?`$filter=isOf('microsoft.graph.win32LobApp')&quot; -Headers $authHeader -ContentType 'Application/Json').value
$results | Select-Object id, displayName
#endregion
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code above is a very simple example that grabs the authentication interactively and then queries Intune for any Win32 applications that have been packaged. Let’s see it in action..&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/06/get-win32apps.gif&amp;quot;&quot; title=&quot;Get Win32 Apps&quot;&gt;&lt;img src=&quot;/assets/images/2020/06/get-win32apps.gif&amp;quot;&quot; alt=&quot;Get Win32 Apps&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Hopefully this has helped you understand the importance of migrating over to MSAL and gives you and idea how to begin migrating your workflows over to this new authentication library!&lt;/p&gt;

&lt;p&gt;For more light reading on MSAL and how to plan migrations away from ADAL, check the links below:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://techcommunity.microsoft.com/t5/azure-active-directory-identity/update-your-applications-to-use-microsoft-authentication-library/ba-p/1257363&quot;&gt;Update your applications to use Microsoft authentication library&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-overview&quot;&gt;MSAL Overview&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-migration&quot;&gt;MSAL Migration&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As always, code from this blog is available &lt;a href=&quot;https://github.com/tabs-not-spaces/CodeDump/tree/master/Get-Win32AppsUsingMSAL&quot;&gt;on my GitHub&lt;/a&gt; and I can be reached on &lt;a href=&quot;https://twitter.com/powers_hell&quot;&gt;Twitter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;— Ben&lt;/p&gt;</content><author><name>Ben</name></author><category term="Graph" /><category term="Intune" /><category term="PowerShell" /><category term="Intune" /><summary type="html">So it seems we need to talk about Graph and authentication again.. Recently, Microsoft announced an official “end of support timeline” for Azure Active Directory Authentication Library (ADAL) which means, any scripts or automation workflows that you use will need to be migrated over to the newer Microsoft Authentication Libraries (MSAL).</summary></entry><entry><title type="html">Installing fonts with PowerShell &amp;amp; Intune</title><link href="https://powers-hell.com/2020/06/09/installing-fonts-with-powershell-intune/" rel="alternate" type="text/html" title="Installing fonts with PowerShell &amp;amp; Intune" /><published>2020-06-08T15:22:21+00:00</published><updated>2020-06-08T15:22:21+00:00</updated><id>https://powers-hell.com/2020/06/09/installing-fonts-with-powershell-intune</id><content type="html" xml:base="https://powers-hell.com/2020/06/09/installing-fonts-with-powershell-intune/">&lt;p&gt;So this seems like a fairly simple and innocuous task - the marketing department comes to you and ask for a handful of new fonts to be deployed to all devices..&lt;/p&gt;

&lt;p&gt;Previously you may have solved this request using Group Policy - but if you are managing your devices with Intune, where do you even start?&lt;/p&gt;

&lt;p&gt;With PowerShell &amp;amp; Win32 app deployments of course!&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;create&quot;&gt;Create&lt;/h2&gt;

&lt;p&gt;First let’s scaffold out our new application project we are going to make - in the example code below we are just going to put everything in the root of our system drive.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;New-Item &quot;$env:SystemDrive\FontsToDeploy\Fonts&quot; -ItemType Directory -Force
New-Item &quot;$env:SystemDrive\FontsToDeploy\Fonts\install.ps1&quot; -ItemType File -Force
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, let’s grab the fonts that the marketing department has asked us to install and place them inside the &lt;strong&gt;Fonts&lt;/strong&gt; folder.&lt;/p&gt;

&lt;p&gt;Open up &lt;strong&gt;install.ps1&lt;/strong&gt; (the file created in the example code above) in your favourite editor (that’s VS-Code, right?) and we will begin the fun stuff.&lt;/p&gt;

&lt;p&gt;We will begin by inserting a very simple function into our install script that will do all of the heavy lifting of this installation.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;#region functions
function Install-Fonts {
    param (
        [Parameter(Mandatory = $true)]
        [string]$FontFile
    )
    try {
        $font = $fontFile | split-path -Leaf
        If (!(Test-Path &quot;c:\windows\fonts\$($font)&quot;)) {
            switch (($font -split &quot;\.&quot;)[-1]) {
                &quot;TTF&quot; {
                    $fn = &quot;$(($font -split &quot;\.&quot;)[0]) (TrueType)&quot;
                    break
                }
                &quot;OTF&quot; {
                    $fn = &quot;$(($font -split &quot;\.&quot;)[0]) (OpenType)&quot;
                    break
                }
            }
            Copy-Item -Path $fontFile -Destination &quot;C:\Windows\Fonts\$font&quot; -Force
            New-ItemProperty -Name $fn -Path &quot;HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Fonts&quot; -PropertyType string -Value $font
        }
    }
    catch {
        write-warning $_.exception.message
    }
}
#endregion
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, not much is required - the function is just checking if the font file is a *.TTF or *.OTF file, copying the file to the font folder and setting a registry entry in HKLM to expose the new font on the system to all users of the device.&lt;/p&gt;

&lt;p&gt;Now that we have our function added, all we need to do is step through our fonts folder and send each font through the function to be installed on the system.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;foreach ($f in $(Get-ChildItem $PSScriptRoot\fonts)) {
    Install-Fonts -FontFile $f.fullName
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We should probably also add some error handling to the solution - this will be provided in the final solution in GitHub.&lt;/p&gt;

&lt;h2 id=&quot;package&quot;&gt;Package&lt;/h2&gt;

&lt;p&gt;Once our install.ps1 file is created, we need to convert the project to a single file that we can upload to Intune.&lt;/p&gt;

&lt;p&gt;I’ve spoken about this at length elsewhere, but surprisingly haven’t mentioned it here, so I’ll touch on the process, but I will keep it brief..&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Download a copy of the &lt;strong&gt;&lt;a href=&quot;https://github.com/microsoft/Microsoft-Win32-Content-Prep-Tool&quot;&gt;Win32 Content Prep Tool&lt;/a&gt;&lt;/strong&gt;. Store it somewhere central (I tend to keep tools like this in a folder in the root of my system drive, or in the root of the project I am working on.)&lt;/li&gt;
  &lt;li&gt;Open PowerShell and set your path to the root of the Application Project we made earlier.&lt;/li&gt;
  &lt;li&gt;Call the Win32 Content Prep Tool from PowerShell.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;&amp;amp; C:\PathToTools\IntuneWinAppUtil.exe -c C:\Fonts -s Install.ps1 -o C:\Fonts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/06/createwin32.gif&quot; title=&quot;Create Win32 App Package&quot;&gt;&lt;img src=&quot;/assets/images/2020/06/createwin32.gif&quot; alt=&quot;Create Win32 App Package&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;deploy&quot;&gt;Deploy&lt;/h2&gt;

&lt;p&gt;Now that we have our *.intunewin package, we can move over to endpoint.microsoft.com and add a new “Windows App (Win32)” application.&lt;/p&gt;

&lt;p&gt;I won’t detail the steps here as it’s been heavily &lt;a href=&quot;https://docs.microsoft.com/en-us/mem/intune/apps/apps-win32-app-management&quot;&gt;documented by Microsoft&lt;/a&gt; and &lt;a href=&quot;https://www.asquaredozen.com/2019/08/21/troubleshooting-win32-app-installs-in-intune/&quot;&gt;the&lt;/a&gt; &lt;a href=&quot;https://www.inthecloud247.com/deploy-win32-apps-with-microsoft-intune/&quot;&gt;greater&lt;/a&gt; &lt;a href=&quot;https://www.anoopcnair.com/intune-win32-app-deployment/&quot;&gt;community&lt;/a&gt; &lt;a href=&quot;https://www.youtube.com/watch?v=x-RMjhzGXxA&amp;amp;t=50s&quot;&gt;already&lt;/a&gt;, just make sure that you:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Deploy the solution using the &lt;strong&gt;system context&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Set the detection method to look for one or more of the resultant font files that will end up in C:\windows\fonts&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Hopefully this shows how much can be done with PowerShell &amp;amp; Intune - obviously font installation is a relatively simple task, but using this concept, you can use win32 apps to deliver scripts and related payloads to your devices quickly and securely.&lt;/p&gt;

&lt;p&gt;As always, code for this post is available on &lt;a href=&quot;https://github.com/tabs-not-spaces/CodeDump/tree/master/Install-Fonts&quot;&gt;GitHub&lt;/a&gt; and I am always available for a chat on &lt;a href=&quot;https://twitter.com/powers_hell&quot;&gt;Twitter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;— Ben&lt;/p&gt;</content><author><name>Ben</name></author><category term="Intune" /><category term="PowerShell" /><category term="PowerShell" /><summary type="html">So this seems like a fairly simple and innocuous task - the marketing department comes to you and ask for a handful of new fonts to be deployed to all devices.. Previously you may have solved this request using Group Policy - but if you are managing your devices with Intune, where do you even start? With PowerShell &amp;amp; Win32 app deployments of course!</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://powers-hell.com/assets/images/2020/06/createwin32.gif" /><media:content medium="image" url="https://powers-hell.com/assets/images/2020/06/createwin32.gif" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Rapidly build Autopilot VMs with Hyper-V and PowerShell!</title><link href="https://powers-hell.com/2020/05/18/rapidly-build-autopilot-vms-with-hyper-v-and-powershell/" rel="alternate" type="text/html" title="Rapidly build Autopilot VMs with Hyper-V and PowerShell!" /><published>2020-05-18T06:27:00+00:00</published><updated>2020-05-18T06:27:00+00:00</updated><id>https://powers-hell.com/2020/05/18/rapidly-build-autopilot-vms-with-hyper-v-and-powershell</id><content type="html" xml:base="https://powers-hell.com/2020/05/18/rapidly-build-autopilot-vms-with-hyper-v-and-powershell/">&lt;p&gt;Picture this scenario - you are at the pointy end of a major modern management project and it’s time to test every policy, configuration and application at scale and quickly.&lt;/p&gt;

&lt;p&gt;What do you do? With infinite money, infinite time and a willing client, you take over their VC meeting room and stack dozens of devices on a desk and blast slayer while you verify your builds ( this literally has happened to me)..&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;But what if you don’t have infinite money, time or an understanding client? That’s where Hyper-V and my latest module &lt;a href=&quot;https://www.powershellgallery.com/packages/Intune.HV.Tools&quot;&gt;Intune.HV.Tools&lt;/a&gt; come in handy!&lt;/p&gt;

&lt;p&gt;Over the last few days, me and my fellow nerd army (&lt;a href=&quot;https://twitter.com/OnPremCloudGuy&quot;&gt;Steve&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/AdamGrossTX&quot;&gt;Adam&lt;/a&gt; and &lt;a href=&quot;https://twitter.com/BruceSaaaa&quot;&gt;Bruce&lt;/a&gt;) have polished our VM provisioning script to something that we are proud enough to publish to the PowerShell Gallery.&lt;/p&gt;

&lt;p&gt;Enough intro - let’s dive right in.&lt;/p&gt;

&lt;p&gt;Open your favourite terminal as admin - PowerShell 5.1 or 7 will work. Haven’t installed 7 yet? &lt;a href=&quot;https://github.com/PowerShell/powershell/releases&quot;&gt;give it a go&lt;/a&gt;, it’s easy to install and awesome.&lt;/p&gt;

&lt;p&gt;Let’s begin by installing the module..&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;Install-Module Intune.HV.Tools -Scope CurrentUser -Force
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once the module is installed, we need to set up our device using the functions contained within..&lt;/p&gt;

&lt;p&gt;Now let’s initialize everything..&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;Initialize-HVTools -Path &quot;C:\lab&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All we are doing here is specifying where we want our VMs to be stored and preparing the configuration file - which we can look at by running the “Get-HVToolsConfig” command..&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/05/initialize.gif&quot; title=&quot;Initialize&quot;&gt;&lt;img src=&quot;/assets/images/2020/05/initialize.gif&quot; alt=&quot;Initialize&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Now that we have our configuration file initialized, let’s add stuff to it!&lt;/p&gt;

&lt;p&gt;The next thing we need to add is details of our windows installation media - in the example below we are using the latest “2004” build of windows 10..&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;Add-ImageToConfig -ImageName &quot;2004&quot; -IsoPath C:\Path\To\Images\en_windows_10_business_editions_version_2004_x64_dvd_d06ef8c5.iso
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can add as many images to the solution as we want - all we need to do is make sure each one has a unique name - as shown below, I’ve added builds 1909 and 2004 to my lab..&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/05/add-imagetoconfig.gif&quot; title=&quot;Add image to config&quot;&gt;&lt;img src=&quot;/assets/images/2020/05/add-imagetoconfig.gif&quot; alt=&quot;Add image to config&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Once we have our image library added to the config, let’s add some of our tenants (one at a time of course..)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;Add-TenantToConfig -TenantName &quot;Powers-Hell&quot; -ImageName &quot;2004&quot; -AdminUpn &quot;AdminEmail@Powers-Hell.com&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What’s cool about the &lt;strong&gt;Add-TenantToConfig&lt;/strong&gt; cmdlet is that the &lt;strong&gt;ImageName&lt;/strong&gt; parameter autocompletes from the available images that we added in the step before. Only have one image? press Tab and it’ll autocomplete. You added a few images? Tab through and find the one you want to use!&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/05/add-tenantoconfig.gif&quot; title=&quot;Add tenant to config&quot;&gt;&lt;img src=&quot;/assets/images/2020/05/add-tenantoconfig.gif&quot; alt=&quot;Add tenant to config&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Alright, we’ve got our images and our tenants configured, lastly we need to add our Hyper-V VLAN details - most of us probably just have the “Default Switch” that was set up when we install Hyper-V, but *some* of us have complex setups, so let’s solve that.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;Add-NetworkToConfig -VSwitchName 'SuperUniqueSwitchName'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The cmdlet actually auto-completes against any virtual switches you might have set up, so as always, just tab through and find the switch you want to assign to your machines..&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/05/add-networktoconfig.gif&quot; title=&quot;Add network to config&quot;&gt;&lt;img src=&quot;/assets/images/2020/05/add-networktoconfig.gif&quot; alt=&quot;Add network to config&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;If you have a virtual network that requires a &lt;strong&gt;VLanID&lt;/strong&gt; you can also apply that by using the &lt;strong&gt;-VlandID&lt;/strong&gt; parameter..&lt;/p&gt;

&lt;p&gt;Alright, once our configuration is set up, it’s time to build our VMs. For this example I’m going to build 3 VMs with a single CPU and 2gb of memory to enroll to the “Powers-Hell” tenant..&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;New-ClientVM -TenantName 'Powers-Hell' -NumberOfVMs 3 -CPUsPerVM 1 -VMMemory 2gb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first time you build a VM from an image it needs to create a &lt;strong&gt;reference image&lt;/strong&gt; which can take some time - this will only need to be done once per image.&lt;/p&gt;

&lt;p&gt;We will also check for any available Autopilot configuration profiles. If we want to skip that and just spin up test machines we can use the &lt;strong&gt;-SkipAutoPilot&lt;/strong&gt; switch..&lt;/p&gt;

&lt;p&gt;Once we’ve captured the Autopilot configuration profile we will use the local copy moving forward..&lt;/p&gt;

&lt;p&gt;Let’s watch what happens once we already have the reference image created..&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://i0.wp.com/i.imgur.com/ix05KH2.gif?w=1170&amp;#038;ssl=1&quot; title=&quot;Run the code&quot;&gt;&lt;img src=&quot;https://i0.wp.com/i.imgur.com/ix05KH2.gif?w=1170&amp;#038;ssl=1&quot; alt=&quot;Run the code&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Awesome - we now have 3 machines we can use to verify our Autopilot configuration, all other Intune policies, configurations and applications work.&lt;/p&gt;

&lt;p&gt;The usual caveat emptor rules apply - this works for me - I’ve tested it pretty heavily, &lt;strong&gt;but it may not work for you.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;If it doesn’t work for you, please raise an issue on the &lt;a href=&quot;https://github.com/tabs-not-spaces/Intune.HV.Tools&quot;&gt;GitHub&lt;/a&gt; and I’ll try fix it for you.&lt;/p&gt;

&lt;p&gt;There are plenty of things I plan to add to this - so please check back regularly!&lt;/p&gt;

&lt;p&gt;As always, &lt;a href=&quot;https://github.com/tabs-not-spaces/Intune.HV.Tools&quot;&gt;Source code for this post can be found here&lt;/a&gt;, the official module can be found &lt;a href=&quot;https://www.powershellgallery.com/packages/Intune.HV.Tools&quot;&gt;here&lt;/a&gt;, and I can always be reached on &lt;a href=&quot;https://twitter.com/powers_hell&quot;&gt;twitter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;— Ben&lt;/p&gt;</content><author><name>Ben</name></author><category term="Azure" /><category term="Intune" /><category term="PowerShell" /><category term="Hyper-V" /><category term="Intune" /><summary type="html">Picture this scenario - you are at the pointy end of a major modern management project and it’s time to test every policy, configuration and application at scale and quickly. What do you do? With infinite money, infinite time and a willing client, you take over their VC meeting room and stack dozens of devices on a desk and blast slayer while you verify your builds ( this literally has happened to me)..</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://powers-hell.com/assets/images/2020/05/new-clientVMDemo-1.gif" /><media:content medium="image" url="https://powers-hell.com/assets/images/2020/05/new-clientVMDemo-1.gif" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Create a bootable Windows 10 Autopilot device with PowerShell!</title><link href="https://powers-hell.com/2020/05/04/create-a-bootable-windows-10-autopilot-device-with-powershell/" rel="alternate" type="text/html" title="Create a bootable Windows 10 Autopilot device with PowerShell!" /><published>2020-05-04T03:58:14+00:00</published><updated>2020-05-04T03:58:14+00:00</updated><id>https://powers-hell.com/2020/05/04/create-a-bootable-windows-10-autopilot-device-with-powershell</id><content type="html" xml:base="https://powers-hell.com/2020/05/04/create-a-bootable-windows-10-autopilot-device-with-powershell/">&lt;p&gt;The most common complaint that I’ve received from people over the last few years around Intune / Autopilot / Modern Management is that people find it frustrating how much effort is involved in getting a device prepared to handover to a client for Autopilot enrollment.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;I totally agree - the sales pitch we are all given is that your staff can go out to a big-box store, buy a laptop and in minutes be greeted with a “welcome to mega-corp” login screen.&lt;/p&gt;

&lt;p&gt;What is never told to us is that before we do any of this, we need to:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;make sure a CLEAN copy of windows 10 is installed on the device - which it never is.&lt;/li&gt;
  &lt;li&gt;Capture the hardware hash of the device and upload it to Intune.&lt;/li&gt;
  &lt;li&gt;Finally, if the device is already past the OOBE, re-image the device and hand it over to the staff member..&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Hardly the autonomous, streamlined sales pitch we’ve been sold - is it?&lt;/p&gt;

&lt;p&gt;Well, I’m here to say I want to make it a little less painful with my first published PowerShell module - &lt;a href=&quot;https://www.powershellgallery.com/packages/Intune.USB.Creator/1.0.0.420&quot;&gt;Intune.USB.Creator&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;This is a solution developed over the last few years and road-tested with multiple clients and environments - something that is reliable enough that I’m happy enough to share it as a complete solution - something I rarely do due to being an obsessive perfectionist…&lt;/p&gt;

&lt;p&gt;Let’s get into how we use it!&lt;/p&gt;

&lt;h2 id=&quot;pre-requirements&quot;&gt;Pre-Requirements&lt;/h2&gt;

&lt;p&gt;First things first, we need to make sure the device you are going to use to build the Autopilot device has a few pre-requisites:&lt;/p&gt;

&lt;p&gt;The module was written primarily for &lt;a href=&quot;https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-windows?view=powershell-7&quot;&gt;PowerShell 7&lt;/a&gt; - if you don’t have it yet, there’s a bunch of ways to get it on your machine. Below is probably the easiest of the lot..&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;Invoke-Expression &quot;&amp;amp; { $(Invoke-RestMethod -Method Get -Uri &quot;https://aka.ms/install-powershell.ps1&quot;) } -UseMSI&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Some of the helper functions rely on other modules - so let’s install those (using PowerShell 7 of course..)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;Install-Module WindowsAutoPilotIntune -Scope CurrentUser -Force
Install-Module Microsoft.Graph.Intune -Scope CurrentUser -Force
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The module uses Windows 10 installation media to create the bootable media. This can be procured from many locations - if you do not have access to this, someone you work with will - just make sure you have a copy of the latest *.iso on your device.&lt;/p&gt;

&lt;p&gt;Finally, let’s install the Intune.USB.Creator module..&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;Install-Module Intune.USB.Creator -Scope CurrentUser -Force
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;how-to-use&quot;&gt;How to use&lt;/h2&gt;

&lt;p&gt;Once all the pre-requirements are installed, plug a USB into our device and let’s create an Autopilot provisioning device.&lt;/p&gt;

&lt;p&gt;Open up PowerShell 7 as an administrator and we will type in the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;Publish-ImageToUSB -winPEPath &quot;https://githublfs.blob.core.windows.net/storage/WinPE.zip&quot; -windowsIsoPath &quot;C:\path\to\win10.iso&quot; -getAutopilotCfg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hitting enter will kick off the device provisioning code..&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://i1.wp.com/i.imgur.com/u4HOn0y.gif?w=1170&amp;#038;ssl=1&quot; title=&quot;Using the module&quot;&gt;&lt;img src=&quot;https://i1.wp.com/i.imgur.com/u4HOn0y.gif?w=1170&amp;#038;ssl=1&quot; alt=&quot;Using the module&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;A few things to note on each parameter:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;WinPEPath&lt;/strong&gt; (Required) - I’ve put a copy of WinPE up on my own storage account - feel free to use it, but if the cost of storage ends up too much, I will take this down. So grab a copy now and store it locally. Consider this fair warning.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;WindowsIsoPath&lt;/strong&gt; (Not required) - as mentioned in the pre-requirements section, you need to source your own copy of Windows 10. This shouldn’t be difficult. Try and get a copy of the “multi-edition” so you can build different variants if required. If you don’t provide a path to a copy of Windows 10, the device will still be provisioned, but there will be nothing added to the solution except for WinPE.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;GetAutopilotCfg&lt;/strong&gt; (Not required) - this is a simple switch to allow you to log in to an Azure tenant and capture the Autopilot configuration files. If you omit this, you will end up with a provisioning device that installs windows 10 and does nothing else.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Once our USB has been created, all that is required to do is plug it into our target device and boot from it.&lt;/p&gt;

&lt;p&gt;WinPE will load and trigger the built in provisioning script which will load the operating system onto the device and inject the Autopilot configuration file.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://i2.wp.com/i.imgur.com/v9Ls50M.gif?w=1170&amp;#038;ssl=1&quot; title=&quot;WinPE&quot;&gt;&lt;img src=&quot;https://i2.wp.com/i.imgur.com/v9Ls50M.gif?w=1170&amp;#038;ssl=1&quot; alt=&quot;WinPE&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Once the device has been provisioned - remove the USB and reboot. We should now be greeted with the standard Out of Box Experience, ending with the ability to log in to the tenant we captured the Autopilot configuration from!&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://i0.wp.com/i.imgur.com/KcMT5OP.gif?w=1170&amp;#038;ssl=1&quot; title=&quot;OOBE&quot;&gt;&lt;img src=&quot;https://i0.wp.com/i.imgur.com/KcMT5OP.gif?w=1170&amp;#038;ssl=1&quot; alt=&quot;OOBE&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Pretty cool, if I do say so myself.&lt;/p&gt;

&lt;p&gt;Using this solution should provide you with a bootable USB that will get you from “out of box” to “ready to enrol” in less than 5 minutes.&lt;/p&gt;

&lt;p&gt;As usual, source code for everything demonstrated here is available on &lt;a href=&quot;https://github.com/tabs-not-spaces/Intune.USB.Creator&quot;&gt;GitHub&lt;/a&gt;, the module itself is available on the &lt;a href=&quot;https://www.powershellgallery.com/packages/Intune.USB.Creator&quot;&gt;PowerShell Gallery&lt;/a&gt; and I am always up for a chat on &lt;a href=&quot;https://twitter.com/powers_hell&quot;&gt;Twitter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;— Ben&lt;/p&gt;</content><author><name>Ben</name></author><category term="Azure" /><category term="Intune" /><category term="PowerShell" /><category term="Autopilot" /><category term="Intune" /><category term="PowerShell" /><summary type="html">The most common complaint that I've received from people over the last few years around Intune / Autopilot / Modern Management is that people find it frustrating how much effort is involved in getting a device prepared to handover to a client for Autopilot enrollment.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://powers-hell.com/assets/images/2020/05/usb-provision.gif" /><media:content medium="image" url="https://powers-hell.com/assets/images/2020/05/usb-provision.gif" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>