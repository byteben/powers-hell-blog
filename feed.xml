<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2021-05-30T07:15:16+00:00</updated><id>/feed.xml</id><title type="html">Powers Hell</title><subtitle>Great power is great fun</subtitle><entry><title type="html">Working with Intune Settings Catalog using PowerShell and Graph</title><link href="/2021/03/08/working-with-intune-settings-catalog-using-powershell-and-graph/" rel="alternate" type="text/html" title="Working with Intune Settings Catalog using PowerShell and Graph" /><published>2021-03-08T12:46:00+00:00</published><updated>2021-03-08T12:46:00+00:00</updated><id>/2021/03/08/working-with-intune-settings-catalog-using-powershell-and-graph</id><content type="html" xml:base="/2021/03/08/working-with-intune-settings-catalog-using-powershell-and-graph/">&lt;p&gt;Microsoft has recently introduced even more ways to create device configuration profiles..&lt;/p&gt;

&lt;p&gt;The new profile type, named &lt;strong&gt;Settings Catalog&lt;/strong&gt;, allows us to explicitly define and configure a policy that has &lt;strong&gt;only&lt;/strong&gt; the settings that they want for that profile, nothing more. Additionally, the existing configuration profiles and ADMX templates have been migrated to the &lt;strong&gt;templates&lt;/strong&gt; profile type.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/33951277/119915226-66caae00-bfa5-11eb-8cc5-4eccfce7787e.png&quot; title=&quot;Create a setting profile&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/33951277/119915226-66caae00-bfa5-11eb-8cc5-4eccfce7787e.png&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I sat down with &lt;a href=&quot;https://twitter.com/MikeDanoski&quot;&gt;Mike Danoski&lt;/a&gt; for an in-depth chat about this on the &lt;a href=&quot;https://intune.training&quot; data-type=&quot;URL&quot; data-id=&quot;https://intune.training&quot;&gt;Intune.Training&lt;/a&gt; Channel (video below).&lt;/p&gt;

&lt;div class=&quot;video-container&quot;&gt;
    &lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/sqIKcWXPvyI&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;After spending time with Mike and seeing how settings catalog profiles work from the endpoint portal user interface, I immediately wanted to see what I could do with this new device management framework via graph.&lt;/p&gt;

&lt;p&gt;So let’s dive in and play!&lt;/p&gt;

&lt;h2 id=&quot;pulling-settings-catalog-policies-from-graph&quot;&gt;&lt;strong&gt;Pulling settings catalog policies from Graph&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;First, let’s create a policy from the endpoint portal and see what is required to retrieve the policy data.&lt;/p&gt;

&lt;p&gt;For this demo, I’ve created a simple settings catalog with a few settings around bitlocker as shown below.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/33951277/119915357-ad200d00-bfa5-11eb-97fc-2cef877def1a.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/33951277/119915357-ad200d00-bfa5-11eb-97fc-2cef877def1a.png&quot; alt=&quot;image-1&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The first thing we need to do, as always, is authenticate to graph - At this point I shouldn’t need to explain what is happening here. We will use the msal.ps module to make things easier.&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot; title=&quot;Configure Authentication for Graph.&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell&quot;&gt;$params = @{
    ClientId = 'd1ddf0e4-d672-4dae-b554-9d5bdfd93547'
    TenantId = 'powers-hell.com'
    DeviceCode = $true
}
$AuthHeader = @{Authorization = (Get-MsalToken @params).CreateAuthorizationHeader()}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we’ve authenticated to graph, let’s use the new graph endpoint &lt;strong&gt;configurationPolicies&lt;/strong&gt; to have a look at how this new feature looks in the backend.&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot; title=&quot;Get configurationPolicies&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell&quot;&gt;$baseUri = &quot;https://graph.microsoft.com/beta/deviceManagement&quot;
$restParam = @{
    Method = 'Get'
    Uri = &quot;$baseUri/configurationPolicies&quot;
    Headers = $authHeaders
    ContentType = 'Application/json'
}

$configPolicies = Invoke-RestMethod @restParam
$configPolicies.value&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, the code above is quite simple, and looking at the resultant data shows we get some basic data back showing all available &lt;strong&gt;settings catalog&lt;/strong&gt; policies that are in our tenant (in our case just the one).&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/33951277/119915408-ca54db80-bfa5-11eb-9be7-d9d02f8cd82c.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/33951277/119915408-ca54db80-bfa5-11eb-9be7-d9d02f8cd82c.png&quot; alt=&quot;image-2&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Ok, so we’ve got the basic metadata of our policy - so let’s grab the id from the previous call and dive in further..&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;$policyId = $configPolicies.value[0].id #grabbing the id from the previous code block
$restParam = @{
    Method = 'Get'
    Uri = &quot;$baseUri/configurationPolicies('$policyId')/settings&quot;
    Headers = $authHeaders
    ContentType = 'Application/json'
}

$configPolicySettings = Invoke-RestMethod @restParam
$configPolicySettings.value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code above returns data on all available settings that we configured in our policy..&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/33951277/119915446-e5bfe680-bfa5-11eb-95ee-c997cae4af14.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/33951277/119915446-e5bfe680-bfa5-11eb-95ee-c997cae4af14.png&quot; alt=&quot;image-3&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;if we drill in to one of the &lt;strong&gt;settingInstance&lt;/strong&gt; objects, we should see more info..&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/33951277/119915455-ea849a80-bfa5-11eb-8e0a-e3b960be372e.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/33951277/119915455-ea849a80-bfa5-11eb-8e0a-e3b960be372e.png&quot; alt=&quot;image-4&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;As we can see, this particular setting is for &lt;strong&gt;allow warning for other disk encryption&lt;/strong&gt; - as clearly defined in the &lt;strong&gt;definitionId&lt;/strong&gt; value. If we drill into the &lt;strong&gt;choiceSettingValue&lt;/strong&gt; item, we will see the applied value and any other child properties within that setting..&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/33951277/119915465-efe1e500-bfa5-11eb-868b-3201648c081f.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/33951277/119915465-efe1e500-bfa5-11eb-868b-3201648c081f.png&quot; alt=&quot;image-5&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Here we can see the value of &lt;strong&gt;allow warning for other disk encryption&lt;/strong&gt; is set to 0 - or false, which correlates to our policy set from the endpoint portal.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/33951277/119915536-1011a400-bfa6-11eb-8421-eeca2c61bcb9.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/33951277/119915536-1011a400-bfa6-11eb-8421-eeca2c61bcb9.png&quot; alt=&quot;image-6&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Here we can see the &lt;strong&gt;child&lt;/strong&gt; setting of &lt;strong&gt;allow standard user encryption&lt;/strong&gt; with the setting value of 1 - or true.&lt;/p&gt;

&lt;p&gt;This example shows how simple it is to capture the basic building blocks of a settings catalog policy. But for those interested to dig deeper, why not check out what happens when you run the same example from above while expanding the &lt;strong&gt;settingDefinitions&lt;/strong&gt; property..&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/33951277/119915557-1acc3900-bfa6-11eb-8374-b50a0a1b2d82.gif&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/33951277/119915557-1acc3900-bfa6-11eb-8374-b50a0a1b2d82.gif&quot; alt=&quot;settingsDefinition&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Cool, huh? literally everything about each and every setting is available to us if we just spend the time to dig into graph a little bit!&lt;/p&gt;

&lt;h2 id=&quot;building-a-policy-from-scratch&quot;&gt;Building a policy from scratch&lt;/h2&gt;

&lt;p&gt;Now, before we begin, I’m going to put this out there - settings catalog policies are probably not the easiest things to build from scratch..&lt;/p&gt;

&lt;p&gt;There is LOTS of metadata that you need to know for each setting before you can build out the policies. However, the concepts shown below can also be leveraged to maintain &lt;strong&gt;reference templates&lt;/strong&gt; that can be captured and redeployed to other tenants to allow seamless management of multiple tenants with minimal effort.&lt;/p&gt;

&lt;p&gt;Enough stalling, let’s see what’s required.&lt;/p&gt;

&lt;h3 id=&quot;getting-all-settings-data&quot;&gt;Getting all settings data&lt;/h3&gt;

&lt;p&gt;So the first question that you may be asking, is, “How do I get the data that I need for the settings that I want to add to my catalog policy?” Luckily, Microsoft has an endpoint in graph that will return all possible settings currently available for the settings catalog.&lt;/p&gt;

&lt;p&gt;We can capture all necessary metadata on those available settings by using the &lt;strong&gt;deviceManagement/configurationSettings&lt;/strong&gt; endpoint.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;$restParam = @{
    Method = &quot;Get&quot;
    Uri = &quot;$baseUri/configurationSettings&quot;
    Headers = $authHeaders
    ContentType = 'Application/Json'
}
$settingsData = Invoke-RestMethod @restParam
$settingsData.value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let’s run the above code and see what we get back..&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/33951277/119915626-40f1d900-bfa6-11eb-9bd0-cab0d19c0e2f.gif&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/33951277/119915626-40f1d900-bfa6-11eb-9bd0-cab0d19c0e2f.gif&quot; alt=&quot;settingsCatapalooza&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Well… that was a bit much wasn’t it! at the time of writing, there is around 2,100 settings available in the settings catalog library with more to come until it is at parity with all existing methods of device configuration (configuration items, ADMX templates, endpoint baselines etc).&lt;/p&gt;

&lt;p&gt;Let’s filter the settings by a setting &lt;strong&gt;definitionId&lt;/strong&gt; that we know (notice that the definitionId isnt a GUID? welcome to the future…)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;$settingsData.value | where {$_.id -eq 'device_vendor_msft_bitlocker_allowwarningforotherdiskencryption'}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/33951277/119915662-52d37c00-bfa6-11eb-8d82-623eafe6e2b1.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/33951277/119915662-52d37c00-bfa6-11eb-8d82-623eafe6e2b1.png&quot; alt=&quot;image-7&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Weird… doesn’t that look the same as the expanded &lt;strong&gt;settingsDefinitions&lt;/strong&gt; content from earlier? That’s because it is literally the same data! We can dig into this data to find out the available options for each setting, but let’s skip that for now and just build our example policy from scratch..&lt;/p&gt;

&lt;h3 id=&quot;posting-a-settings-catalog-policy-to-intune-from-graph&quot;&gt;Posting a settings catalog policy to Intune from Graph&lt;/h3&gt;

&lt;p&gt;Conceptually we now should understand what’s required here. We have some metadata around what the policy is called to which we attach whichever settings we want attributed to our new policy profile. So let’s rebuild the original policy in PowerShell!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;$baseUri = 'https://graph.microsoft.com/beta/deviceManagement/configurationPolicies'

#region build the policy
$newPolicy = [pscustomobject]@{
    name         = &quot;Bitlocker Policy from PowerShell&quot;
    description  = &quot;we built this from PowerShell!&quot;
    platforms    = &quot;windows10&quot;
    technologies = &quot;mdm&quot;
    settings     = @(
        @{
            '@odata.type'   = &quot;#microsoft.graph.deviceManagementConfigurationSetting&quot;
            settingInstance = @{
                '@odata.type'       = &quot;#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance&quot;
                settingDefinitionId = &quot;device_vendor_msft_bitlocker_allowwarningforotherdiskencryption&quot;
                choiceSettingValue  = @{
                    '@odata.type' = &quot;#microsoft.graph.deviceManagementConfigurationChoiceSettingValue&quot;
                    value         = &quot;device_vendor_msft_bitlocker_allowwarningforotherdiskencryption_0&quot;
                    children      = @(
                        @{
                            '@odata.type'       = &quot;#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance&quot;
                            settingDefinitionId = &quot;device_vendor_msft_bitlocker_allowstandarduserencryption&quot;
                            choiceSettingValue  = @{
                                '@odata.type' = &quot;#microsoft.graph.deviceManagementConfigurationChoiceSettingValue&quot;
                                value         = &quot;device_vendor_msft_bitlocker_allowstandarduserencryption_0&quot;
                            }
                        }
                    )
                }
            }
        }
        @{
            '@odata.type'   = &quot;#microsoft.graph.deviceManagementConfigurationSetting&quot;
            settingInstance = @{
                '@odata.type'       = &quot;#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance&quot;
                settingDefinitionId = &quot;device_vendor_msft_bitlocker_requiredeviceencryption&quot;
                choiceSettingValue  = @{
                    '@odata.type' = &quot;#microsoft.graph.deviceManagementConfigurationChoiceSettingValue&quot;
                    value         = &quot;device_vendor_msft_bitlocker_requiredeviceencryption_1&quot;
                }
            }
        }
    )
}
#endregion
#region post the request
$restParams = @{
    Method      = 'Post'
    Uri         = $baseUri
    body        = ($newPolicy | ConvertTo-Json -Depth 20)
    Headers     = $authHeaders
    ContentType = 'Application/Json'
}
Invoke-RestMethod @restParams
#endregion
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once we run this - within seconds we should have a replicated policy in our tenant!&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/33951277/119915697-65e64c00-bfa6-11eb-8cab-06a15f01b7e8.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/33951277/119915697-65e64c00-bfa6-11eb-8cab-06a15f01b7e8.png&quot; alt=&quot;image-8&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;As mentioned earlier, building these from scratch is tricky - but if you read between the lines, knowing how to capture pre-built policies via graph and using the captured JSON payload to post the same policy to a new tenant (or a few hundred tenants) should make multi-tenant device management less painful.&lt;/p&gt;

&lt;p&gt;— Ben&lt;/p&gt;</content><author><name>Ben</name></author><category term="Azure" /><category term="Graph" /><category term="Intune" /><category term="Powershell" /><category term="Azure" /><category term="Intune" /><category term="Powershell" /><summary type="html">Microsoft has recently introduced even more ways to create device configuration profiles.. The new profile type, named Settings Catalog, allows us to explicitly define and configure a policy that has only the settings that they want for that profile, nothing more. Additionally, the existing configuration profiles and ADMX templates have been migrated to the templates profile type.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/images/2021/03/settingsCatapalooza.gif" /><media:content medium="image" url="/assets/images/2021/03/settingsCatapalooza.gif" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Publishing PowerShell scripts to Intune with Graph</title><link href="/2021/01/19/publishing-powershell-scripts-to-intune-with-graph/" rel="alternate" type="text/html" title="Publishing PowerShell scripts to Intune with Graph" /><published>2021-01-19T03:22:12+00:00</published><updated>2021-01-19T03:22:12+00:00</updated><id>/2021/01/19/publishing-powershell-scripts-to-intune-with-graph</id><content type="html" xml:base="/2021/01/19/publishing-powershell-scripts-to-intune-with-graph/">&lt;p&gt;I’ve recently been asked the question - “How can I make sure that the scripts that I publish to Intune are always set to run as 64bit instead of the default 32bit?”&lt;/p&gt;

&lt;p&gt;I thought was a great question with a few simple solutions - so let’s look at the two methods I’ve used in the past to make sure you don’t “fat finger” your way into frustration!&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;enforce-architecture-from-the-script&quot;&gt;Enforce architecture from the script&lt;/h2&gt;

&lt;p&gt;When PowerShell script deployment was initially released within Intune there was no native way to define what architecture the script would run in. This means that the script would always run in the 32bit / x86 environment as the Intune Management Extension agent was launching the scripts and the agent itself was a 32bit agent - it had no way to bootstrap out of the 32bit environment!&lt;/p&gt;

&lt;p&gt;The only solution during this period was to make your scripts bootstrap themselves into 64bit with a little bit of PowerShell magic.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;#region 64-bit elevation
if ($env:PROCESSOR_ARCHITEW6432 -eq &quot;AMD64&quot;) {
    write-Host &quot;pull on those bootstraps...&quot;
    if ($myInvocation.Line) {
        &amp;amp;&quot;$env:WINDIR\sysnative\windowspowershell\v1.0\powershell.exe&quot; -NonInteractive -executionPolicy Bypass -NoProfile $myInvocation.Line
    }
    else {
        &amp;amp;&quot;$env:WINDIR\sysnative\windowspowershell\v1.0\powershell.exe&quot; -NonInteractive -executionPolicy Bypass -NoProfile -file &quot;$($myInvocation.InvocationName)&quot; $args
    }
    exit $lastexitcode
}
#endregion
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Place that code at the top of any script you publish to Intune and you can rest easy knowing that your code will always run in the environment it should be in, regardless if you set it correctly from within Intune or not.&lt;/p&gt;

&lt;h2 id=&quot;avoid-the-endpoint-ui-and-use-graph&quot;&gt;Avoid the Endpoint UI and use Graph&lt;/h2&gt;

&lt;p&gt;Now that the option to set the architecture from within the script deployment, the above solution is conceivably “redundant” - we can set everything when we publish the script in the portal now!&lt;/p&gt;

&lt;p&gt;The problem arises however, because the default architecture setting is set to 32bit instead of the generally expected 64bit, that you can sometimes forget to set the configuration correctly from the portal.&lt;/p&gt;

&lt;p&gt;Luckily, we can move away from the Endpoint portal and use PowerShell and Graph to change the default settings to values and standardize our script publishing to avoid any of those absent-minded “user errors” that are so frustratingly common.&lt;/p&gt;

&lt;p&gt;Like all other configuration settings / device management endpoints that are exposed via Graph, all that is required is to:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Understand how the JSON payload data is formed&lt;/li&gt;
  &lt;li&gt;Authenticate to Graph&lt;/li&gt;
  &lt;li&gt;Build and publish the JSON payload to Graph&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The one extra step for script deployment is that we need to encode the script content into a base64 encoded string so that we can post the file within the JSON payload.&lt;/p&gt;

&lt;p&gt;Let’s dive into the solution together.&lt;/p&gt;

&lt;h3 id=&quot;authentication&quot;&gt;Authentication&lt;/h3&gt;

&lt;p&gt;I’ve covered this ad-nauseum, so I won’t spend time explaining it - but here’s the code snippet we will use for this example. What’s cool about this is we can handle whether or not the end user uses PowerShell 5.1 or 7.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;#region authenticate to Graph
if ($PSVersionTable.PSEdition -ne &quot;Core&quot;) {
    $auth = Get-MsalToken -ClientId &quot;d1ddf0e4-d672-4dae-b554-9d5bdfd93547&quot; -RedirectUri &quot;urn:ietf:wg:oauth:2.0:oob&quot; -Interactive
}
else {
    $auth = Get-MsalToken -ClientId &quot;d1ddf0e4-d672-4dae-b554-9d5bdfd93547&quot; -DeviceCode
}
$script:authToken = @{
    Authorization = $auth.CreateAuthorizationHeader()
}
#endregion
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;encode-the-script-to-a-base64-string&quot;&gt;Encode the script to a base64 string&lt;/h3&gt;

&lt;p&gt;Very simple - but super important. We just need to get the raw content of the script and throw it into the .Net “System.Convert” type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;#region encode the script content to base64
$scriptContent = Get-Content &quot;C:\Path\To\Script.ps1&quot; -Raw
$encodedScriptContent = [System.Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes(&quot;$scriptContent&quot;))
#endregion
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;payload-properties&quot;&gt;Payload properties&lt;/h3&gt;

&lt;p&gt;The required properties for publishing scripts to Graph are quite simple - the endpoint &lt;strong&gt;deviceManagementScripts&lt;/strong&gt; is &lt;a href=&quot;https://docs.microsoft.com/en-us/graph/api/intune-shared-devicemanagementscript-create?view=graph-rest-beta&quot; data-type=&quot;URL&quot; data-id=&quot;https://docs.microsoft.com/en-us/graph/api/intune-shared-devicemanagementscript-create?view=graph-rest-beta&quot;&gt;well documented&lt;/a&gt;, but for simplicity, the only settings we need to understand are listed below:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;Property Name&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;Data Type&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;displayName&lt;/td&gt;
      &lt;td&gt;String&lt;/td&gt;
      &lt;td&gt;Name of the device management script.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;description&lt;/td&gt;
      &lt;td&gt;String&lt;/td&gt;
      &lt;td&gt;Description of the script&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;enforceSignatureCheck&lt;/td&gt;
      &lt;td&gt;Boolean&lt;/td&gt;
      &lt;td&gt;Setting this to False disables signature check.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;fileName&lt;/td&gt;
      &lt;td&gt;String&lt;/td&gt;
      &lt;td&gt;Name of the file being uploaded.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;runas32Bit&lt;/td&gt;
      &lt;td&gt;Boolean&lt;/td&gt;
      &lt;td&gt;Setting this to False sets to 64bit&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;runAsAccount&lt;/td&gt;
      &lt;td&gt;String&lt;/td&gt;
      &lt;td&gt;Execution context - System or User&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;scriptContent&lt;/td&gt;
      &lt;td&gt;Binary&lt;/td&gt;
      &lt;td&gt;Script content - encoded as base64&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;So, knowing what we need, let’s build out the code to build the payload.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;#region build the request body
$postBody = [PSCustomObject]@{
    displayName           = &quot;Powers-Hell Configuration Script&quot;
    description           = &quot;script that configures important things&quot;
    enforceSignatureCheck = $false
    fileName              = &quot;Script.ps1&quot;
    runAs32Bit            = $false
    runAsAccount          = &quot;System&quot;
    scriptContent         = $encodedScriptContent
} | ConvertTo-Json -Depth 10
#endregion
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Quite simple - creating a PSCustomObject, filling in the property values and then immediately converting to a JSON string.&lt;/p&gt;

&lt;h3 id=&quot;post-the-request-to-graph&quot;&gt;Post the request to Graph&lt;/h3&gt;

&lt;p&gt;Once we’ve got out authentication header, we’ve encoded the script contents and built out the JSON payload, all that’s left to do is post the payload to the Graph endpoint.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;#region post the request
$postParams = @{
    Method      = &quot;Post&quot;
    Uri         = &quot;https://graph.microsoft.com/Beta/deviceManagement/deviceManagementScripts&quot;
    Headers     = $script:authToken
    Body        = $postBody
    ContentType = &quot;Application/Json&quot;
}
Invoke-RestMethod @postParams
#endregion
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we use the above basic blocks of code, we can very easily build a simple function to allow us to build out a request to publish scripts to our Intune tenant and by forcing the boolean value of &lt;strong&gt;runAs32Bit&lt;/strong&gt; to $false, we can ensure the script will always run correctly - even if we haven’t had enough coffee yet.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;#requires -module msal.ps
function Publish-ScriptToIntune {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [System.IO.FileInfo]$ScriptFilePath,

        [Parameter(Mandatory = $true)]
        [string]$DisplayName,

        [Parameter(Mandatory = $true)]
        [string]$Description,
        
        [Parameter(Mandatory = $false)]
        [ValidateSet(&quot;System&quot;, &quot;User&quot;)]
        [string]$RunAsAccount = &quot;System&quot;,

        [Parameter(Mandatory = $false)]
        [boolean]$EnforceSignatureCheck,

        [Parameter(Mandatory = $false)]
        [boolean]$RunAs32Bit

    )
    try {
        $script:tick = [char]0x221a
        $errorMsg = $null
        #region authenticate to Graph
        if ($PSVersionTable.PSEdition -ne &quot;Core&quot;) {
            $auth = Get-MsalToken -ClientId &quot;d1ddf0e4-d672-4dae-b554-9d5bdfd93547&quot; -RedirectUri &quot;urn:ietf:wg:oauth:2.0:oob&quot; -Interactive
        }
        else {
            $auth = Get-MsalToken -ClientId &quot;d1ddf0e4-d672-4dae-b554-9d5bdfd93547&quot; -DeviceCode
        }
        if (!($auth)) {
            throw &quot;Authentication failed.&quot;
        }
        $script:authToken = @{
            Authorization = $auth.CreateAuthorizationHeader()
        }
        #endregion
        #region encode the script content to base64
        $scriptContent = Get-Content &quot;$ScriptFilePath&quot; -Raw
        $encodedScriptContent = [System.Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes(&quot;$scriptContent&quot;))
        #endregion
        #region build the request body
        $postBody = [PSCustomObject]@{
            displayName           = $DisplayName
            description           = $Description
            enforceSignatureCheck = $EnforceSignatureCheck
            fileName              = $ScriptFilePath.Name
            runAs32Bit            = $RunAs32Bit
            runAsAccount          = $RunAsAccount
            scriptContent         = $encodedScriptContent
        } | ConvertTo-Json -Depth 10
        #endregion
        Write-Host &quot;`nPosting script content to Intune: &quot; -NoNewline -ForegroundColor Cyan
        #region post the request
        $postParams = @{
            Method      = &quot;Post&quot;
            Uri         = &quot;https://graph.microsoft.com/Beta/deviceManagement/deviceManagementScripts&quot;
            Headers     = $script:authToken
            Body        = $postBody
            ContentType = &quot;Application/Json&quot;
        }
        if ($PSCmdlet.MyInvocation.BoundParameters[&quot;Verbose&quot;].IsPresent) {
            Write-Host &quot;`n&quot;
        }
        $res = Invoke-RestMethod @postParams
        #endregion
    }
    catch {
        $errorMsg = $_.Exception.Message
    }
    finally {
        if ($auth) {
            if ($errorMsg) {
                Write-Host &quot;X`n&quot; -ForegroundColor Red
                Write-Warning $errorMsg
            }
            else {
                if ($PSCmdlet.MyInvocation.BoundParameters[&quot;Verbose&quot;].IsPresent) {
                    $res
                }
                Write-Host &quot;$script:tick Script published to Intune with ID $($res.id)&quot; -ForegroundColor Green
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As always, the code featured is available in my &lt;a href=&quot;https://github.com/tabs-not-spaces/CodeDump/tree/master/Publish-ScriptToIntune&quot;&gt;GitHub&lt;/a&gt; and I’m always up for a chat on &lt;a href=&quot;https://twitter.com/powers_hell&quot;&gt;Twitter&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;— Ben&lt;/p&gt;</content><author><name>Ben</name></author><category term="Azure" /><category term="Graph" /><category term="Intune" /><category term="Powershell" /><category term="Graph" /><category term="Intune" /><category term="Powershell" /><summary type="html">I've recently been asked the question - &quot;How can I make sure that the scripts that I publish to Intune are always set to run as 64bit instead of the default 32bit?&quot; I thought was a great question with a few simple solutions - so let's look at the two methods I've used in the past to make sure you don't &quot;fat finger&quot; your way into frustration!</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/images/2021/01/scriptToGraph.gif" /><media:content medium="image" url="/assets/images/2021/01/scriptToGraph.gif" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Set your Azure VPN connections to “Connect Automatically” with PowerShell</title><link href="/2020/11/28/set-your-azure-vpn-connections-to-connect-automatically-with-powershell/" rel="alternate" type="text/html" title="Set your Azure VPN connections to “Connect Automatically” with PowerShell" /><published>2020-11-28T06:25:27+00:00</published><updated>2020-11-28T06:25:27+00:00</updated><id>/2020/11/28/set-your-azure-vpn-connections-to-connect-automatically-with-powershell</id><content type="html" xml:base="/2020/11/28/set-your-azure-vpn-connections-to-connect-automatically-with-powershell/">&lt;p&gt;One of my clients recently came to me asking for assistance to set up a new VPN solution. The requirements were quite simple - They were building out an Azure Point-To-Site VPN solution and needed me to come up with a way to deliver the connection to the end user devices.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;My first suggestion was to simply use the built-in VPN client that comes with Windows 10. If we use this, we can utilize the native VPN policies within Intune which let us define everything we need - including setting the connection to automatically connect. The problem, as it turned out is the native VPN client has a limit of 25 route rules per connection - something that *shouldn’t* normally be a problem, but was insurmountable in this scenario.&lt;/p&gt;

&lt;p&gt;The next suggestion was to leverage the &lt;a href=&quot;https://www.microsoft.com/en-us/p/azure-vpn-client/9np355qt2sqb&quot; data-type=&quot;URL&quot; data-id=&quot;https://www.microsoft.com/en-us/p/azure-vpn-client/9np355qt2sqb&quot;&gt;Azure VPN Client&lt;/a&gt; from the Microsoft store. This VPN client is designed to compliment the native VPN client and adds support for MFA as well as allowing connections from the native VPN interface.&lt;/p&gt;

&lt;p&gt;The only problem? There is no way to force the “connect automatically” setting in the native VPN client, thus the client’s major requirement was not met.&lt;/p&gt;

&lt;p&gt;Now, the end user can technically go in once the connection is deployed and set it themselves, but there has to be a more reliable way of doing this on behalf of the user - if it can be done via Intune for the native client, surely there has to be a way to enforce the setting? The answer, as always, is a resounding “of course!”.&lt;/p&gt;

&lt;p&gt;Before we begin, the first thing we need to do is convert the config files I was given by my network team into a format that we can silently push out.&lt;/p&gt;

&lt;p&gt;Once you’ve downloaded the Azure P2S config files, the next step is to manually import the config into the Azure VPN client (technically there is a way to do this using CLI parameters, however it’s frustratingly broken at the moment - I’ll talk about that another time!).&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/11/VPNConnectionImport-1.gif&quot; title=&quot;VPN Connection Import&quot;&gt;&lt;img src=&quot;/assets/images/2020/11/VPNConnectionImport-1.gif&quot; alt=&quot;VPN Connection Import&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;What this manual step does is creates the *.PBK file that the VPN client uses to “dial the connection”. Once we have that *.PBK file generated, we can capture the contents, and then deploy it out to other devices via Intune (or Configuration Manager) using a very simple PowerShell script.&lt;/p&gt;

&lt;p&gt;The *.PBK file is stored within the Azure VPN client folder structure in your local app data folder shown below - It’s always the same path which makes all of this very easy to automate!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;%localappdata%\Packages\Microsoft.AzureVpn_8wekyb3d8bbwe\LocalState\rasphone.pbk&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Open the *.pbk file in your favourite editor (that’s VSCode for everyone right?) and let’s move onto the code.&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot; title=&quot;Deploy and configure VPN&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;
#region Configuration
$VPNName = 'Powers Hell VPN Connection'
$VPNGUID = 'F3910F5AC434944F9335C187D7476DB4'
$currentUser = (Get-CimInstance -ClassName WIn32_Process -Filter 'Name=&quot;explorer.exe&quot;' | Invoke-CimMethod -MethodName GetOwner)[0]
$objUser = New-Object System.Security.Principal.NTAccount($currentUser.user)
$strSID = $objUser.Translate([System.Security.Principal.SecurityIdentifier])
$requiredFolder = &quot;C:\Users\$($currentUser.user)\AppData\Local\Packages\Microsoft.AzureVpn_8wekyb3d8bbwe\LocalState&quot;
$rasManKeyPath = &quot;HKLM:\SYSTEM\CurrentControlSet\Services\RasMan\Config&quot; 
#endregion
#region PBK Configuration
$PBKConfig - @&quot;
#Place your PBK contents here...
&quot;@
#endregion
#region Functions
function Write-Log {
    [cmdletbinding()]
    param (
        [string]$logMessage
    )
    Write-Host &quot;[$(Get-Date -Format 'dd-MM-yyyy_HH:mm:ss')] $logMessage&quot; -ForegroundColor Yellow
}
#endregion
#region Deploy VPN
if (!(Test-Path $RequiredFolder -ErrorAction SilentlyContinue)) {
  New-Item $RequiredFolder -ItemType Directory | Out-Null
  $LogLocation = &quot;$RequiredFolder\NewAzureVPNConnectionLog_$(Get-Date -Format 'dd-MM-yyyy_HH_mm_ss').log&quot;
  Start-Transcript -Path $LogLocation -Force -Append
  
  Write-Log &quot;Required folder $RequiredFolder was created on the machine since it wasn't found.&quot;
  New-Item &quot;$RequiredFolder\rasphone.pbk&quot; -ItemType File | Out-Null
  
  Write-Log &quot;File rasphone.pbk has been created in $RequiredFolder.&quot;
  Set-Content &quot;$RequiredFolder\rasphone.pbk&quot; $PBKConfig
  
  Write-Log &quot;File rasphone.pbk has been populated with configuration details.&quot;
  Stop-Transcript | Out-Null
}
else {
  $LogLocation = &quot;$RequiredFolder\NewAzureVPNConnectionLog_$(Get-Date -Format 'dd-MM-yyyy_HH_mm_ss').log&quot;
  Start-Transcript -Path $LogLocation -Force -Append
  
  Write-Log &quot;Folder $RequiredFolder already exists, that means that Azure VPN Client is already installed.&quot;
  if (!(Test-Path &quot;$RequiredFolder\rasphone.pbk&quot; -ErrorAction SilentlyContinue)) {
    
    Write-Log &quot;File rasphone.pbk doesn't exist in $RequiredFolder.&quot;
    New-Item &quot;$RequiredFolder\rasphone.pbk&quot; -ItemType File | Out-Null
    
    Write-Log &quot;File rasphone.pbk has been created in $RequiredFolder.&quot;
    Set-Content &quot;$RequiredFolder\rasphone.pbk&quot; $PBKConfig
    
    Write-Log &quot;File rasphone.pbk has been populated with configuration details.&quot;
    Stop-Transcript | Out-Null
  }
  else {
    Write-Log &quot;File rasphone.pbk already exists in $RequiredFolder.&quot;
    Rename-Item -Path &quot;$RequiredFolder\rasphone.pbk&quot; -NewName &quot;$RequiredFolder\rasphone.pbk_$(Get-Date -Format 'ddMMyyyy-HHmmss')&quot;    
    
    Write-Log &quot;File rasphone.pbk has been renamed to rasphone.pbk_$(Get-Date -Format 'ddMMyyyy-HHmmss'). This file contains old configuration if it will be required in the future (in case it is, just rename it back to rasphone.pbk).&quot;
    New-Item &quot;$RequiredFolder\rasphone.pbk&quot; -ItemType File | Out-Null
    
    Write-Log &quot;New rasphone.pbk file has been created in $RequiredFolder.&quot;
    Set-Content &quot;$RequiredFolder\rasphone.pbk&quot; $PBKConfig
    
    Write-Log &quot;File rasphone.pbk has been populated with configuration details.&quot;
    Stop-Transcript | Out-Null
  }
}
#endregion&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Not much to be said about the above code - all we are doing is pushing out the contents of the *.PBK file to the correct location on the target machines. There is only one important thing to note - I’ve specifically replaced the name and guid from the *.PBK file with variable names to allow me to set them in the configuration at the top of the script. You don’t need to do that yourself, but it makes the solution a little more “reusable”.&lt;/p&gt;

&lt;p&gt;You can see where they normally appear in the screenshot below (lines 1 &amp;amp; 10).&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/11/image.png&quot; title=&quot;PBK Snippet&quot;&gt;&lt;img src=&quot;/assets/images/2020/11/image.png&quot; alt=&quot;PBK Snippet&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Alright, we’ve deployed the VPN - but it still isn’t automatically connecting. Let’s go and figure that out.&lt;/p&gt;

&lt;p&gt;The key to this solution is found in the registry (as always). The auto connection settings can be found in the local machine hive path shown below.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HKLM:\SYSTEM\CurrentControlSet\Services\RasMan\Config&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/11/image-1.png&quot; title=&quot;VPN Registry&quot;&gt;&lt;img src=&quot;/assets/images/2020/11/image-1.png&quot; alt=&quot;VPN Registry&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;As you can see above, for my corporate VPN connection, we are setting a few key values - namely:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;AutoTriggerDisabledProfilesList&lt;/strong&gt; - A list of VPNs specifically set to not automatically connect (done manually by the user).&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;AutoTriggerProfileEntryName&lt;/strong&gt; - The Name of the VPN connection&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;AutoTriggerProfileGUID&lt;/strong&gt; - The HEX GUID of the VPN connection&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;AutoTriggerProfilePhonebookPath&lt;/strong&gt; - The path to the phonebook file&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;UserSID&lt;/strong&gt; - The SID of the user who has set the automatic connection.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Once we understand what is required to set the connection, all we need to do is fill out the data and store it in the correct registry location!&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot; title=&quot;Connect Automatically&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;
#region Functions
function Convert-HexToByte {
  [cmdletbinding()]
  param (
    [string]$HexString
  )
  $splitString = ($HexString -replace '(..)','$1,').Trim(',')
  [byte[]]$hexified = $splitString.Split(',') | ForEach-Object { &quot;0x$_&quot;}
  return $hexified
}
function Set-ComputerRegistryValues {
  param (
      [Parameter(Mandatory = $true)]
      [array]$RegistryInstance
  )
  try {
      foreach ($key in $RegistryInstance) {
          $keyPath = $key.Path
          if (!(Test-Path $keyPath)) {
              Write-Host &quot;Registry path : $keyPath not found. Creating now.&quot; -ForegroundColor Green
              New-Item -Path $key.Path -Force | Out-Null
              Write-Host &quot;Creating item property: $($key.Name)&quot; -ForegroundColor Green
              New-ItemProperty -Path $keyPath -Name $key.Name -Value $key.Value -Type $key.Type -Force
          }
          else {
              Write-Host &quot;Creating item property: $($key.Name)&quot; -ForegroundColor Green
              New-ItemProperty -Path $keyPath -Name $key.Name -Value $key.Value -Type $key.Type -Force
          }
      }
  }
  catch {
      Throw $_.Exception.Message
  }
}
#endregion
#region Configure Always On
[string[]]$autoDisable = (Get-ItemPropertyValue $rasManKeyPath -Name AutoTriggerDisabledProfilesList) | ForEach-Object { if ($_ -ne $VPNName) { $_ }}
$regKeys = @(
  @{
    Path = $rasManKeyPath
    Name = 'AutoTriggerDisabledProfilesList'
    Value = [string[]]$autoDisable
    Type = 'MultiString'
  }
  @{
    Path = $rasManKeyPath
    Name = 'AutoTriggerProfilePhonebookPath'
    Value = &quot;$RequiredFolder\rasphone.pbk&quot;
    Type = 'String'
  }
  @{
    Path = $rasManKeyPath
    Name = 'AutoTriggerProfileEntryName'
    Value = $VPNName
    Type = 'String'
  }
@{
    Path = $rasManKeyPath
    Name = 'UserSID'
    Value = $sid
    Type = 'String'
  }
@{
    Path = $rasManKeyPath
    Name = 'AutoTriggerProfileGUID'
    Value = [Byte[]](Convert-HexToByte -HexString $VPNGUID)
    Type = 'Binary'
  }
)
Set-ComputerRegistryValues $regKeys
#endregion&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Again, most of this code is quite simple - all we are doing is entering some data into the registry.&lt;/p&gt;

&lt;p&gt;The only interesting thing of interest is how I’m converting the VPN GUID from the phonebook file into the Binary format required - which is done with the function &lt;strong&gt;Convert-HexToByte&lt;/strong&gt; show above - that took me a little longer than I’m willing to admit!&lt;/p&gt;

&lt;p&gt;The other thing to be aware of is that deploying the VPN config can be done either in the User or System context - no admin privileges are required, however due to the registry keys being stored in the HKLM hive, admin privileges will be required to set the “connect automatically” section of this solution.&lt;/p&gt;

&lt;p&gt;That’s it for now - if you’ve got any questions about this solution, please reach out to me on &lt;a href=&quot;https://twitter.com/powers_hell&quot;&gt;twitter&lt;/a&gt;, and as always, the code for this post can be found on my &lt;a href=&quot;https://github.com/tabs-not-spaces/CodeDump/tree/master/AzureVPNAutoConnect&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;— Ben&lt;/p&gt;</content><author><name>Ben</name></author><category term="Azure" /><category term="Intune" /><category term="Powershell" /><category term="Intune" /><summary type="html">One of my clients recently came to me asking for assistance to set up a new VPN solution. The requirements were quite simple - They were building out an Azure Point-To-Site VPN solution and needed me to come up with a way to deliver the connection to the end user devices.</summary></entry><entry><title type="html">Deploying Universal Print Printers With PowerShell &amp;#038; Intune</title><link href="/2020/10/25/deploying-universal-print-printers-with-powershell-intune/" rel="alternate" type="text/html" title="Deploying Universal Print Printers With PowerShell &amp;#038; Intune" /><published>2020-10-25T05:21:15+00:00</published><updated>2020-10-25T05:21:15+00:00</updated><id>/2020/10/25/deploying-universal-print-printers-with-powershell-intune</id><content type="html" xml:base="/2020/10/25/deploying-universal-print-printers-with-powershell-intune/">&lt;p&gt;Over the last few weeks I’ve been playing with &lt;strong&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/universal-print/fundamentals/universal-print-whatis&quot;&gt;Universal Print&lt;/a&gt;&lt;/strong&gt; - the cloud print solution developed by Microsoft and I honestly can’t praise it enough.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;Configuring the “infrastructure” for the solution took me less than 5 minutes.. Seriously - Grab a license (free during the public preview), install and configure a connector on a device with line-of-sight to your printer and finally set the printer shares in the Azure portal.&lt;/p&gt;

&lt;p&gt;It was so easy I honestly don’t think I need to talk more about it - &lt;a href=&quot;https://docs.microsoft.com/en-us/universal-print/fundamentals/universal-print-getting-started&quot;&gt;the steps are really well documented over on the Microsoft Docs page&lt;/a&gt;, so start there if you haven’t already set things up.&lt;/p&gt;

&lt;p&gt;The one area that needs a little bit of polish is the way that printers get deployed to our end user devices. &lt;a href=&quot;https://docs.microsoft.com/en-us/universal-print/fundamentals/universal-print-intune-tool&quot;&gt;The current solution&lt;/a&gt; offered by Microsoft has two key requirements:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Deploy the &lt;strong&gt;Universal Print printer provisioning tool&lt;/strong&gt; via Intune (as a win32 package)&lt;/li&gt;
  &lt;li&gt;Deploy a CSV file with a list of printers, along with a batch script to deploy the CSV file to a key location.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Once the two packages are deployed, printers will then install on the client devices &lt;strong&gt;upon the next reboot or logon event&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;There’s two things I don’t currently love about this solution and wanted to try and improve:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Is there a way we can make the printers install on the client devices without having to wait for a reboot or a logon event?&lt;/li&gt;
  &lt;li&gt;Can we do this with PowerShell?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The answer to both of these statements was a resounding “of course we can!” What I was surprised to find was how simple it actually was.&lt;/p&gt;

&lt;p&gt;This guide assumes you’ve already configured everything else - licensing, setting up the Universal Print connector etc. If you haven’t done that, go and sort that out.&lt;/p&gt;

&lt;p&gt;Alright, let’s jump in - we are going to deploy this solution as a “proactive remediation” script via Intune, although there is nothing stopping you deploying as a standard PowerShell script, or as a packaged win32 application.&lt;/p&gt;

&lt;h2 id=&quot;detection&quot;&gt;Detection&lt;/h2&gt;

&lt;pre title=&quot;Detection Script&quot; class=&quot;wp-block-code&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;#region printer list
$availablePrinters = @(
    &quot;Printer A&quot;
    &quot;Printer B&quot;
    &quot;Printer C&quot;
    &quot;Printer D&quot;
)
$notFound = 0
#endregion
#region check the printers exist
try {
    foreach ($p in $availablePrinters) {
        if (!(Get-Printer -Name $p -ErrorAction SilentlyContinue)) {
            $notFound ++
        }
    }
}
catch {
    $errorMsg = $_.Exception.Message
}
finally {
    if ($errorMsg) {
        Write-Warning $errorMsg
        exit 1
    }
    else {
        if ($notFound) {
            Write-Warning &quot;$notFound printers not found locally..&quot;
            exit 1
        }
        else {
            Write-Host &quot;All printers detected..&quot;
            exit 0
        }
    }
}
#endregion&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code above is pretty simple, simply list the names of the printers you want to make sure exist on the device - if any of them are missing, they will be flagged and the script will exit with a &lt;strong&gt;non-zero&lt;/strong&gt; exit code, which will alert Intune that the remediation script is required to run.&lt;/p&gt;

&lt;h2 id=&quot;remediation&quot;&gt;Remediation&lt;/h2&gt;

&lt;pre title=&quot;Remediation Script&quot; class=&quot;wp-block-code&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;#region printer list
$availablePrinters = @(
    [pscustomobject]@{
        SharedID   = '2f8aa4d8-8c21-4d37-9506-3da446bcf9ea'
        SharedName = 'Printer A'
        IsDefault  = 'Yes'
    }
    [pscustomobject]@{
        SharedID   = 'c288bc70-8e14-4c5b-9f82-428ecf3ab63a'
        SharedName = 'Printer B'
        IsDefault  = $null
    }
    [pscustomobject]@{
        SharedID   = '478a29db-7bdd-46a7-a75e-e0d61167988c'
        SharedName = 'Printer C'
        IsDefault  = $null
    }
    [pscustomobject]@{
        SharedID   = '896262c5-59ca-4b92-becf-074feb25fccc'
        SharedName = 'Printer D'
        IsDefault  = $null
    }
)
#endregion
try {
    $configurationPath = &quot;$env:appdata\UniversalPrintPrinterProvisioning\Configuration&quot;
    if (!(Test-Path $configurationPath -ErrorAction SilentlyContinue)) {
        New-Item $configurationPath -ItemType Directory -Force | Out-Null
    }
    $printCfg = ($availablePrinters | ConvertTo-Csv -NoTypeInformation | ForEach-Object { $_ -replace '&quot;', &quot;&quot; } ) -join [System.Environment]::NewLine
    $printCfg | Out-File &quot;$configurationPath\printers.csv&quot; -Encoding ascii -NoNewline
    Start-Process &quot;${env:ProgramFiles(x86)}\UniversalPrintPrinterProvisioning\Exe\UPPrinterInstaller.exe&quot; -Wait -WindowStyle Hidden
}
catch {
    $errorMsg = $_.Exception.Message
}
finally {
    if ($errorMsg) {
        Write-Warning $errorMsg
        exit 1
    }
    else {
        Write-Host &quot;Universal Printer Installer configured and launched. Printers should appear shortly..&quot;
        exit 0
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The remediation script is also quite simple, the &lt;strong&gt;$availablePrinters&lt;/strong&gt; array contains the details of each Universal Print printer that we need to map the printer to the device.&lt;/p&gt;

&lt;p&gt;Head to &lt;strong&gt;Universal Print &amp;gt; Printer Shares&lt;/strong&gt; (In the Azure portal), select each printer share and make note of the &lt;strong&gt;Share ID&lt;/strong&gt; and the &lt;strong&gt;Name&lt;/strong&gt; of the share. For each printer, you will create a &lt;strong&gt;psCustomObject&lt;/strong&gt; containing the &lt;strong&gt;ShareID, SharedName&lt;/strong&gt; and whether or not you want this printer to be flagged as a &lt;em&gt;default&lt;/em&gt; printer or not.&lt;figure class=&quot;wp-block-image size-full&quot;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/10/image-1.png&quot; title=&quot;Printer A&quot;&gt;&lt;img src=&quot;/assets/images/2020/10/image-1.png&quot; alt=&quot;Printer A&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The rest of the script is also fairly straight forward. What we are doing is building out the “printers.csv” file that the &lt;strong&gt;Universal Print Printer Provisioning Service&lt;/strong&gt; uses to validate which printers to install.&lt;/p&gt;

&lt;p&gt;The real &lt;em&gt;magic&lt;/em&gt; of the script (which isn’t really that magic) is on line 32. The print provisioning service that gets installed by the Universal Print installation media sits in the background and listens for a &lt;strong&gt;user logon&lt;/strong&gt; event. Once this event is found, the service triggers another executable - &lt;strong&gt;UPPrinterInstaller.exe&lt;/strong&gt; which looks for the *.csv file we have created, authenticates to Graph, validates the print share details and then kicks off a &lt;strong&gt;Web Services for Devices (WSD)&lt;/strong&gt; process to map the available printers.&lt;/p&gt;

&lt;p&gt;Now, I’ll be the first to admit that the solution here is a little “kludgy” - I initially intended to reverse engineer the &lt;strong&gt;UPPrinterInstaller.exe&lt;/strong&gt; to identify exactly &lt;em&gt;how&lt;/em&gt; that WSD process works, however this works well enough - for now at least.&lt;/p&gt;

&lt;h2 id=&quot;notes&quot;&gt;Notes&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;the Proactive Remediation detection and remediation scripts need to be run in the &lt;strong&gt;user context&lt;/strong&gt; as opposed to system - make sure you set that in the solution.&lt;/li&gt;
  &lt;li&gt;The default printer value will &lt;strong&gt;NOT&lt;/strong&gt; work the way it is intended if you have the &lt;strong&gt;Let Windows manage my default printer&lt;/strong&gt; setting enabled (found within the &lt;strong&gt;Printers &amp;amp; scanners&lt;/strong&gt; section of settings). Which makes sense - but just be aware of that.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I will continue to dig into this solution to try and make it a little more elegant - with the hopes that any advancements I make with the provisioning process might just make it into the official solution once it leaves Public Preview.&lt;/p&gt;

&lt;p&gt;As always, the code referenced in this guide is available in &lt;a href=&quot;https://github.com/tabs-not-spaces/CodeDump/tree/master/Universal-Print-Printer-Install&quot;&gt;GitHub&lt;/a&gt; and I can be reached on &lt;a href=&quot;https://twitter.com/powers_hell&quot;&gt;Twitter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;— Ben&lt;/p&gt;</content><author><name>Ben</name></author><category term="Azure" /><category term="Graph" /><category term="Intune" /><category term="Powershell" /><category term="Universal Print" /><category term="Intune" /><category term="Powershell" /><category term="Universal Print" /><summary type="html">Over the last few weeks I’ve been playing with Universal Print - the cloud print solution developed by Microsoft and I honestly can’t praise it enough.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/images/2020/10/universalprint.gif" /><media:content medium="image" url="/assets/images/2020/10/universalprint.gif" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Preparing custom image templates with Azure Image Builder &amp;amp; PowerShell</title><link href="/2020/09/20/preparing-custom-image-templates-with-azure-image-builder-powershell/" rel="alternate" type="text/html" title="Preparing custom image templates with Azure Image Builder &amp;amp; PowerShell" /><published>2020-09-20T10:44:14+00:00</published><updated>2020-09-20T10:44:14+00:00</updated><id>/2020/09/20/preparing-custom-image-templates-with-azure-image-builder-powershell</id><content type="html" xml:base="/2020/09/20/preparing-custom-image-templates-with-azure-image-builder-powershell/">&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/azure/virtual-machines/windows/image-builder-overview&quot;&gt;Azure Image Builder&lt;/a&gt; (AIB) is Microsoft’s solution to configure and customize virtual machine images. The concept of it is pretty great: Pick a reference image from the public market place, apply some customization built around &lt;a href=&quot;https://www.packer.io/&quot;&gt;HashiCorp’s Packer&lt;/a&gt;, hit build and what you are left with is a fully customized template image that can be hosted in Azure as a managed image or a VHD file.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;Now, here’s the problem - AIB is still very much in preview and is tricky to set up. There’s lots of &lt;a href=&quot;http://xenithit.blogspot.com/2020/06/using-azure-image-builder-and-azure.html&quot;&gt;great guides&lt;/a&gt; on how to set up your tenant to use AIB, but I wanted to try and simplify the initial configuration of your tenant so you can get past the “preview hurdles” and just get straight into building your image templates.&lt;/p&gt;

&lt;p&gt;So, I went and published a “helper” module to do just that! &lt;a href=&quot;https://www.powershellgallery.com/packages/az.imagebuilder.tools&quot;&gt;Az.ImageBuilder.Tools&lt;/a&gt; is a module that will assist you with configuring your tenant to enable the features, custom roles and managed identities required to start playing with AIB.&lt;/p&gt;

&lt;p&gt;Let’s dive right in - by the end of this guide, we will be able to:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Set up our tenant to use AIB and Shared Image Gallery (SIB)&lt;/li&gt;
  &lt;li&gt;Build the AIB template from the Win10 EVD (multi session) image from the Azure Marketplace&lt;/li&gt;
  &lt;li&gt;Add a customization script to pre-install software to our AIB template&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All right - let’s get into it!&lt;/p&gt;

&lt;h2 id=&quot;pre-requirements&quot;&gt;Pre-Requirements&lt;/h2&gt;

&lt;h3 id=&quot;grab-the-modules&quot;&gt;Grab the modules&lt;/h3&gt;

&lt;p&gt;First, let’s install the &lt;a href=&quot;https://www.powershellgallery.com/packages/az.imagebuilder.tools&quot;&gt;Az.ImageBuilder.Tools&lt;/a&gt; module - this will not only install my helper module, but all other required pre-req modules.&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;Install-Module Az.ImageBuilder.Tools&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;authenticate-to-your-tenant&quot;&gt;Authenticate to your tenant&lt;/h3&gt;

&lt;p&gt;Make sure you are connected to your tenant!&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;
#region Connect to Azure
Connect-AzAccount
$azContext = Get-AzContext
$subscriptionID = $azContext.Subscription.Id
#endregion
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;enable-the-features-and-providers-required-for-aib--sig&quot;&gt;Enable the features and providers required for AIB / SIG&lt;/h3&gt;

&lt;p&gt;This one is going to take a minute - run the below command and check back in 15..&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;Invoke-AIBProviderCheck&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run the same command in 15~ minutes to verify the features and providers are registered. If you don’t want to do this step, add &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-wait&lt;/code&gt; to the command. Once everything is ready, you should see the below.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/09/invoke-aibprovidercheck.gif&quot; title=&quot;Imvoke-AIBProvider&quot;&gt;&lt;img src=&quot;/assets/images/2020/09/invoke-aibprovidercheck.gif&quot; alt=&quot;Imvoke-AIBProvider&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;define-the-variables&quot;&gt;Define the variables&lt;/h2&gt;

&lt;p&gt;You don’t need to set these up, but c’mon - this guide is clearly setting you up for an automated template process… so let’s go ahead and treat it like that.&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;$resourceGroupName = 'AIB-ResourceGroup'
$location = 'eastus'
$imageTemplateName = 'Win10-20H1-EVD'
$sharedGalleryName = 'SharedImageGallery'
$imageDefinitionName = 'Win10EVD'
$runOutputName = 'winClientR01'
$imageConfig = @{
    OsState   = 'generalized'
    OsType    = 'Windows'
    Publisher = 'MicrosoftWindowsDesktop'
    Offer     = 'office-365'
    Sku       = '20h1-evd-o365pp'
    Version   = 'latest'
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A few notes on the variables above:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The values in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$imageConfig&lt;/code&gt; are set specifically for the current build of the Win10 EVD image from the marketplace - don’t change those unless you know there is a new version.&lt;/li&gt;
  &lt;li&gt;Everything else is fair game - &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$resourceGroupName&lt;/code&gt; defines the name of the resource group you want to put the AIB / SIG resources into - if it doesn’t exist, don’t worry - the next step will sort that out.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;initialize-azure-image-builder-aib&quot;&gt;Initialize Azure Image Builder (AIB)&lt;/h2&gt;

&lt;p&gt;Now we need to create the custom roles and managed identity - these are the steps that stop most people from moving ahead - no worry, I’ve sorted it out.&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;$mIDParams = @{
    AzureContext      = $azContext
    ResourceGroupName = $resourceGroupName
    Location          = $location
    IdentityName      = 'aibIdentity'
}
$managedIdentity = Initialize-AzureImageBuilder @mIDParams&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This command will create the resource group if its missing, create a managed identity and apply custom roles required to work with AIB / SIG.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/09/initialize-azureImageBuilder.gif&quot; title=&quot;Initializa-AzureImageBuilder&quot;&gt;&lt;img src=&quot;/assets/images/2020/09/initialize-azureImageBuilder.gif&quot; alt=&quot;Initializa-AzureImageBuilder&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;create-the-shared-image-gallery-sig&quot;&gt;Create the Shared Image Gallery (SIG)&lt;/h2&gt;

&lt;p&gt;AIB allows us to host our image templates as VHDs or in a &lt;a href=&quot;https://docs.microsoft.com/en-us/azure/virtual-machines/windows/shared-image-galleries&quot;&gt;Shared Image Gallery&lt;/a&gt; - I won’t go into what SIG is here, but for the sake of clarity - SIG is a great solution to store and manage image templates.&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;$azGalleryParams = @{
    Name              = $sharedGalleryName
    ResourceGroupName = $resourceGroupName
    Location          = $location
}
New-AzGallery @azGalleryParams&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;prepare-the-source-image&quot;&gt;Prepare the source image&lt;/h2&gt;

&lt;p&gt;Ok, we are going to set up the source image and the definitions - nothing too exciting here. The commands and their parameters should be self-explanatory.&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;# create the source image
$srcObjParams = @{
    SourceTypePlatformImage = $true
    Publisher               = $imageConfig.Publisher
    Offer                   = $imageConfig.Offer
    Sku                     = $imageConfig.Sku
    Version                 = $imageConfig.Version
}
$srcPlatform = New-AzImageBuilderSourceObject @srcObjParams
# create the image definition
$imageDefParams = @{
    GalleryName       = $sharedGalleryName
    ResourceGroupName = $resourceGroupName
    Location          = $location
    Name              = $imageDefinitionName
    OsState           = $imageconfig.OsState
    OsType            = $imageConfig.OsType
    Publisher         = ([mailaddress]$azContext.account.id).Host
    Offer             = $imageConfig.Offer
    Sku               = $imageConfig.Sku
}
New-AzGalleryImageDefinition @imageDefParams
# create the distributor object
$distObjParams = @{
    SharedImageDistributor = $true
    ArtifactTag            = @{ tag = 'dis-share' }
    GalleryImageId         = &quot;/subscriptions/$subscriptionID/resourceGroups/$resourceGroupName/providers/Microsoft.Compute/galleries/$sharedGalleryName/images/$imageDefinitionName&quot;
    ReplicationRegion      = $location
    RunOutputName          = $runOutputName
    ExcludeFromLatest      = $false
}
$disSharedImg = New-AzImageBuilderDistributorObject @distObjParams&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;add-customization&quot;&gt;Add customization&lt;/h2&gt;

&lt;p&gt;Here’s the secret sauce - you can add as many customization objects as you want to this. It’s documented well - go check it out. But for now, I’ve hosted a simple PowerShell script on GitHub and I’m going to use that as my single customization step.&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;# Add customizer step
$imgCustomParams = @{
    PowerShellCustomizer = $true
    CustomizerName       = 'MountAppShareAndRunInstaller'
    RunElevated          = $true
    scriptUri            = 'https://raw.githubusercontent.com/tabs-not-spaces/Az.ImageBuilder.Tools/master/Samples/AppInstall.ps1'
}
$customizer = New-AzImageBuilderCustomizerObject @imgCustomParams&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;combine-all-the-ingredients&quot;&gt;Combine all the ingredients..&lt;/h2&gt;

&lt;p&gt;Now we have our shared image gallery, source object, distributor object, image definition and customization steps - let’s add them all together and prep the template.&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;# Create AIB Template
$imgTemplateParams = @{
    ImageTemplateName      = $imageTemplateName
    ResourceGroupName      = $resourceGroupName
    Source                 = $srcPlatform
    Distribute             = $disSharedImg
    Customize              = $customizer
    Location               = $location
    UserAssignedIdentityId = $managedIdentity.ResourceId
}
New-AzImageBuilderTemplate @ImgTemplateParams&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is going to take a little while - around 10 minutes. Keep an eye on the status of the task with the following command.&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;Get-AzImageBuilderTemplate -ImageTemplateName $imageTemplateName -ResourceGroupName $resourceGroupName&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;build-the-template&quot;&gt;Build the template&lt;/h2&gt;

&lt;p&gt;Everything is ready - now we just need to kick off the build - again, this is going to take a while. From my experience, I’ve found it takes anywhere from 15 minutes to an Hour - it entirely depends on what customization options you are adding.&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;# Start the template build task
# check back on the $job variable for the build status
$job = Start-AzImageBuilderTemplate -ResourceGroupName $resourceGroupName -Name $imageTemplateName -AsJob&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If your customization script stalls or is written in a way that can’t bomb out elegantly, you may find yourself in a situation where the build process stalls - the image builder template process will time out after 4 hours by default. This can be changed.&lt;/p&gt;

&lt;p&gt;While this step is running, you can monitor the process in one of 3 ways.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;check on the status of the $job variable - while it’s running it’ll advise you. Same for when it’s completed.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/09/start-azimagebuildertemplate.gif&quot; title=&quot;Start-AzImageBuilderTemplate&quot;&gt;&lt;img src=&quot;/assets/images/2020/09/start-azimagebuildertemplate.gif&quot; alt=&quot;Start-AzImageBuilderTemplate&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Check the build status directly from the AIB API&lt;/li&gt;
&lt;/ul&gt;

&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;Get-AIBBuildStatus -AzureContext $azContext -ResourceGroupName $resourceGroupName -ImageTemplateName $imageTemplateName&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/09/get-aibbuildstatus.gif&quot; title=&quot;Get-AIBBuildStatus&quot;&gt;&lt;img src=&quot;/assets/images/2020/09/get-aibbuildstatus.gif&quot; alt=&quot;Get-AIBBuildStatus&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Finally, you can check the &lt;strong&gt;VERY&lt;/strong&gt; verbose logs of packer - jump into your resource groups list - you’ll see a new resource group similarly named to the resource group you defined at the start of this guide.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/09/image-1.png&quot; title=&quot;AIB Resource Group&quot;&gt;&lt;img src=&quot;/assets/images/2020/09/image-1.png&quot; alt=&quot;AIB Resource Group&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Inside the storage account, there will be a container named &lt;strong&gt;packerlogs.&lt;/strong&gt; click through the packerlogs container and the internal randomly generated folder and monitor the &lt;strong&gt;customization.log&lt;/strong&gt; file. There’s &lt;a href=&quot;https://docs.microsoft.com/en-us/azure/virtual-machines/linux/image-builder-troubleshoot#customization-log&quot;&gt;good documentation&lt;/a&gt; on this, and it’s going to help you out if you need to troubleshoot your customization script.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Once your template is built - you are done! You now have a customized template that you can use to build out virtual machines… or if you are paying attention - session hosts for Windows Virtual Desktop!&lt;/p&gt;

&lt;p&gt;Stay tuned for a post on how to build WVD session hosts using AIB and PowerShell!&lt;/p&gt;

&lt;p&gt;As always, sample code used in this guide are available on &lt;a href=&quot;https://github.com/tabs-not-spaces/Az.ImageBuilder.Tools/tree/master/Samples&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;— Ben&lt;/p&gt;</content><author><name>Ben</name></author><category term="Azure" /><category term="PowerShell" /><category term="Automation" /><category term="WVD" /><category term="Azure Image Builder" /><category term="PowerShell" /><category term="Automation" /><category term="WVD" /><summary type="html">Azure Image Builder (AIB) is Microsoft’s solution to configure and customize virtual machine images. The concept of it is pretty great: Pick a reference image from the public market place, apply some customization built around HashiCorp’s Packer, hit build and what you are left with is a fully customized template image that can be hosted in Azure as a managed image or a VHD file.</summary></entry><entry><title type="html">Dynamically set the time zone of a device in Intune using Azure Maps &amp;amp; PowerShell</title><link href="/2020/08/31/setting-the-time-zone-of-an-intune-managed-device-using-azure-maps-powershell/" rel="alternate" type="text/html" title="Dynamically set the time zone of a device in Intune using Azure Maps &amp;amp; PowerShell" /><published>2020-08-30T21:20:59+00:00</published><updated>2020-08-30T21:20:59+00:00</updated><id>/2020/08/31/setting-the-time-zone-of-an-intune-managed-device-using-azure-maps-powershell</id><content type="html" xml:base="/2020/08/31/setting-the-time-zone-of-an-intune-managed-device-using-azure-maps-powershell/">&lt;p&gt;Let me start off by saying I wish I didn’t have to write this post. Setting the correct time zone of a Windows device shouldn’t be this difficult, especially with all of the management possibilities provided to us with Intune and the entire endpoint management stack. But here we are!&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;I get it though. At one point, as &lt;a href=&quot;https://twitter.com/mniehaus&quot;&gt;Michael Neihaus&lt;/a&gt; &lt;a href=&quot;https://oofhours.com/2019/12/20/configuring-time-zones-part-2/&quot;&gt;has written about previously&lt;/a&gt;, even if we could configure the time zone during the Out of Box Experience, everything was hinged on the timings of certificates and policies reaching the device within an agreed time frame.&lt;br /&gt;
If the time zone changed on a device during that process it had the possibility to break the entire enrollment process. This has since been (for the most part) resolved if you are using Windows 10 2004 (20h1) as your operating system.&lt;/p&gt;

&lt;p&gt;I’m hopeful that eventually, we will be able to configure the time zone as part of the OOBE, but until that time comes, I’d like to share some ways that I currently solve this problem using Azure Maps &amp;amp; PowerShell.&lt;/p&gt;

&lt;p&gt;Most solutions I’ve found involve creating custom OMA-URI policies to set the value of the time zone which works in some scenarios, but isn’t elegant enough to handle the real world problem of managing devices and users located all over the world. So let’s change that.&lt;/p&gt;

&lt;h2 id=&quot;setting-time-zone-from-device-gps-data&quot;&gt;Setting time zone from device GPS data&lt;/h2&gt;

&lt;p&gt;This one is fun but does require that &lt;strong&gt;location services&lt;/strong&gt; are turned on which, by default are disabled. This can be enforced by device configuration policies, but there are obvious security implications and you may need to discuss this with your organization before enabling.&lt;/p&gt;

&lt;p&gt;The solution below converts the GPS latitude and longitude data to the required windows time zone data by using an API available through Azure Maps.&lt;/p&gt;

&lt;p&gt;Pricing is super affordable and the “included free quantity” means that for small to medium-sized businesses, there is a chance you’d end up not paying a cent. For reference, here are the available &lt;a href=&quot;https://docs.microsoft.com/en-us/azure/azure-maps/choose-pricing-tier&quot;&gt;plans&lt;/a&gt; and &lt;a href=&quot;https://azure.microsoft.com/en-us/pricing/details/azure-maps/&quot;&gt;pricing&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;configuring-azure-maps&quot;&gt;Configuring Azure Maps&lt;/h3&gt;

&lt;p&gt;This is super easy, but it’s still worth documenting!&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Open up your Azure portal and create a new resource.&lt;/li&gt;
  &lt;li&gt;Search the marketplace for “Azure Maps” and create an account.&lt;/li&gt;
  &lt;li&gt;Fill out the relevant fields and choose your pricing tier (as mentioned above, S0 will be &lt;strong&gt;more&lt;/strong&gt; than enough for this demo.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/08/image-4.png&quot; title=&quot;Create Azure Maps Account&quot;&gt;&lt;img src=&quot;/assets/images/2020/08/image-4.png&quot; alt=&quot;Create Azure Maps Account&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Once the account is created, go to the resource and head to the &lt;strong&gt;Authentication&lt;/strong&gt; page. Make note of one of the &lt;strong&gt;Shared Keys&lt;/strong&gt;. We will use these to authenticate to the service.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;writing-the-code&quot;&gt;Writing the code&lt;/h3&gt;

&lt;p&gt;Now let’s grab our GPS data and send it to the Azure Maps API!&lt;/p&gt;

&lt;p&gt;The above code is fairly simple - we are adding the &lt;strong&gt;System.Device&lt;/strong&gt; assembly to our session and creating and starting a new &lt;strong&gt;GeoCoordinateWatcher&lt;/strong&gt; object to capture the GPS data of our device.&lt;/p&gt;

&lt;p&gt;If we look at the results that are stored in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$gw&lt;/code&gt; variable we should see the property name &lt;strong&gt;Permission&lt;/strong&gt;. If we step into that, we should see the location data required for the next step.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/08/image-5.png&quot; title=&quot;$gw variable&quot;&gt;&lt;img src=&quot;/assets/images/2020/08/image-5.png&quot; alt=&quot;$gw variable&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Now that we have our Latitude and Longitude data stored in a variable, next we need to form the request to the Azure Maps API.&lt;/p&gt;

&lt;p&gt;Looking at the contents of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$locData&lt;/code&gt; we should now see some cool data.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/08/image-6.png&quot; title=&quot;location data&quot;&gt;&lt;img src=&quot;/assets/images/2020/08/image-6.png&quot; alt=&quot;location data&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Stepping into the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$locData.TimeZones&lt;/code&gt; property should give us even more info.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/08/image-7.png&quot; title=&quot;Timezones data&quot;&gt;&lt;img src=&quot;/assets/images/2020/08/image-7.png&quot; alt=&quot;Timezones data&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The final step is to convert the value we see in &lt;strong&gt;Id&lt;/strong&gt; from the IANA code, to the format our computer needs to set the time zone.&lt;/p&gt;

&lt;p&gt;All we are doing above is getting a list of Windows time zone IDs and matching them to the IANA time zone ID. Once we have a match, using the native &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Set-TimeZone&lt;/code&gt; allows us to dynamically set our device time zone with relative ease!&lt;/p&gt;

&lt;h2 id=&quot;setting-time-zone-from-public-ip-address&quot;&gt;Setting Time Zone from public IP address&lt;/h2&gt;

&lt;p&gt;So what if you aren’t allowed to enable location services? Or what if you are provisioning virtual machines that don’t have access to the GPS data? Luckily, there is another way to get our location data - from the publicly facing IP address of the device.&lt;/p&gt;

&lt;p&gt;For this example, we will use a free API from &lt;a href=&quot;https://ipinfo.io&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://ipinfo.io/&quot;&gt;https://ipinfo.io&lt;/a&gt;. You can use this API without registering, however, it is heavily rate-limited without providing an access token, so just register an account - it allows 50,000 API calls a month for free which is more than enough for this scenario.&lt;/p&gt;

&lt;p&gt;Once you’ve registered and signed in, grab a copy of the access token from the dashboard - we will use it below.&lt;/p&gt;

&lt;p&gt;If we look at the value of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$locData&lt;/code&gt; we should see similar data from our first example.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/08/image-9.png&quot; title=&quot;$locData&quot;&gt;&lt;img src=&quot;/assets/images/2020/08/image-9.png&quot; alt=&quot;$locData&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Jackpot! The value of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$locData.timezone&lt;/code&gt; is a properly formatted IANA Id. We could reuse the code from the first example to match up the IANA Id to the Windows time zone Id - or we can save an API call and grab a copy of the results and compare them in the code. Let’s see how that would look.&lt;/p&gt;

&lt;p&gt;Obviously, that’s a LOT more code, but it does save us another API call, which if we are deploying to tens of thousands of devices could in the end save us being charged for API use!&lt;/p&gt;

&lt;p&gt;I personally prefer and actually do use the second method for setting time zones as during my testing I’m invariably building VMs before I move to physical devices (sometimes I don’t even end up onto physical devices!), so being able to get a rough estimate of the location-based on public IP is much more reliable.&lt;/p&gt;

&lt;p&gt;How you deploy this to your devices is up to personal preference and operational requirements of course. I’ve generally had success simply deploying as a configuration script where I am happy for it to only run once, however bundling this with a scheduled task to run once a week or once a month to maintain time zone reliability is another great option.&lt;/p&gt;

&lt;p&gt;I’ve polished up the code from this article and provided both solutions as ready to deploy scripts, go check them out on my &lt;a href=&quot;https://github.com/tabs-not-spaces/CodeDump/tree/master/Set-Timezone&quot;&gt;GitHub&lt;/a&gt; - just make sure to update the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$apiKey&lt;/code&gt; for either scenario you choose to utilize.&lt;/p&gt;

&lt;p&gt;— Ben&lt;/p&gt;</content><author><name>Ben</name></author><category term="Azure" /><category term="Intune" /><category term="Powershell" /><category term="Intune" /><summary type="html">Let me start off by saying I wish I didn’t have to write this post. Setting the correct time zone of a Windows device shouldn’t be this difficult, especially with all of the management possibilities provided to us with Intune and the entire endpoint management stack. But here we are!</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/images/2020/08/gpsdata.jpg" /><media:content medium="image" url="/assets/images/2020/08/gpsdata.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>